<%- include('partials/head', { pageTitle: map.name }) %>

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<% if (chain.length > 1) { %>
<nav class="map-breadcrumb">
  <a href="/map">Maps</a>
  <% for (let i = 0; i < chain.length; i++) { %>
    <span class="map-breadcrumb-sep">&rsaquo;</span>
    <% if (i < chain.length - 1) { %>
      <a href="/map/<%= chain[i].id %>"><%= MARKER_TYPES[chain[i].map_type] ? MARKER_TYPES[chain[i].map_type].icon : '' %> <%= chain[i].name %></a>
    <% } else { %>
      <span class="map-breadcrumb-current"><%= MARKER_TYPES[chain[i].map_type] ? MARKER_TYPES[chain[i].map_type].icon : '' %> <%= chain[i].name %></span>
    <% } %>
  <% } %>
</nav>
<% } %>

<div class="page-header">
  <h1>
    <span class="map-type-badge map-type-<%= map.map_type %>" style="font-size: 0.9rem; vertical-align: middle;"><%= MARKER_TYPES[map.map_type] ? MARKER_TYPES[map.map_type].icon : 'üåç' %> <%= MARKER_TYPES[map.map_type] ? MARKER_TYPES[map.map_type].label : map.map_type %></span>
    <%= map.name %>
  </h1>
  <div>
    <button type="button" class="btn btn-outline btn-small" id="map-fullscreen-btn" title="Fullscreen">
      <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="15 3 21 3 21 9"></polyline><polyline points="9 21 3 21 3 15"></polyline><line x1="21" y1="3" x2="14" y2="10"></line><line x1="3" y1="21" x2="10" y2="14"></line></svg>
      Fullscreen
    </button>
    <button type="button" class="btn btn-outline btn-small" id="token-picker-btn" title="Place Token">
      <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path><circle cx="12" cy="7" r="4"></circle></svg>
      Tokens
    </button>
    <% if (isDM) { %>
    <button type="button" class="btn btn-outline btn-small" id="npc-picker-btn" title="Place NPC Token" style="border-color: #c0392b; color: #e74c3c;">
      <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="8.5" cy="7" r="4"></circle><path d="M20 8v6M23 11h-6"></path></svg>
      NPCs
    </button>
    <button type="button" class="btn btn-outline btn-small" id="token-scale-btn" title="Scale Tokens">
      <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="15 3 21 3 21 9"></polyline><polyline points="9 21 3 21 3 15"></polyline><line x1="21" y1="3" x2="14" y2="10"></line><line x1="3" y1="21" x2="10" y2="14"></line></svg>
      Scale
    </button>
    <% } %>
    <% if (isDM) { %>
      <button type="button" class="btn btn-outline btn-small" onclick="document.getElementById('upload-form').style.display = document.getElementById('upload-form').style.display === 'none' ? 'block' : 'none'">Upload Map</button>
      <% if (map.created_by === currentUserId || (typeof isAdmin !== 'undefined' && isAdmin)) { %>
        <button type="button" class="btn btn-outline btn-small" id="toggle-hidden-btn" title="<%= map.hidden_by ? 'Unhide Map' : 'Hide Map' %>">
          <%= map.hidden_by ? 'üëÅÔ∏è Unhide' : 'üîí Hide' %>
        </button>
      <% } %>
      <button type="button" class="btn btn-outline btn-small" id="fog-toggle-btn" style="border-color: #2c3e50;" title="Fog of War">
        üå´Ô∏è Fog
      </button>
    <% } %>
    <% if (map.parent_id) { %>
      <a href="/map/<%= map.parent_id %>" class="btn btn-outline btn-small">Back to Parent</a>
    <% } %>
    <a href="/map" class="btn btn-outline btn-small">All Maps</a>
  </div>
</div>

<% if (isDM) { %>
  <div id="upload-form" style="display:none; margin-bottom: 1rem;">
    <div class="card">
      <form action="/map/<%= map.id %>/upload" method="POST" enctype="multipart/form-data">
      <input type="hidden" name="_csrf" value="<%= csrfToken %>">
        <div class="form-group">
          <label for="map_image">Map Image (JPG, PNG, GIF, WebP &mdash; max 30MB)</label>
          <input type="file" name="map_image" id="map_image" accept="image/*">
        </div>
        <button type="submit" class="btn btn-primary btn-small">Upload</button>
      </form>
    </div>
  </div>
<% } %>

<div class="card map-wrapper" id="map-wrapper">
  <button type="button" class="map-fullscreen-close" id="map-fullscreen-close" title="Exit fullscreen">&times;</button>
  <!-- Fullscreen floating toolbar -->
  <div class="map-fs-toolbar" id="map-fs-toolbar">
    <button type="button" class="map-fs-btn" id="fs-token-btn" title="Tokens">
      <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path><circle cx="12" cy="7" r="4"></circle></svg>
      <span>Tokens</span>
    </button>
    <% if (isDM) { %>
    <button type="button" class="map-fs-btn map-fs-btn-npc" id="fs-npc-btn" title="NPCs">
      <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="8.5" cy="7" r="4"></circle><path d="M20 8v6M23 11h-6"></path></svg>
      <span>NPCs</span>
    </button>
    <button type="button" class="map-fs-btn" id="fs-scale-btn" title="Scale">
      <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="15 3 21 3 21 9"></polyline><polyline points="9 21 3 21 3 15"></polyline><line x1="21" y1="3" x2="14" y2="10"></line><line x1="3" y1="21" x2="10" y2="14"></line></svg>
      <span>Scale</span>
    </button>
    <button type="button" class="map-fs-btn" id="fs-fog-btn" title="Fog of War">
      <span style="font-size:16px;">üå´Ô∏è</span>
      <span>Fog</span>
    </button>
    <% } %>
  </div>
  <div class="map-container" id="map-container"></div>
  <% if (isDM) { %>
  <!-- NPC Sidebar (drag-to-place) -->
  <div id="npc-sidebar" class="npc-sidebar" style="display:none;">
    <div class="npc-sidebar-header">
      <span>NPCs</span>
      <button type="button" class="npc-sidebar-close" id="npc-sidebar-close">&times;</button>
    </div>
    <input type="text" id="npc-sidebar-search" placeholder="Search..." class="npc-sidebar-search">
    <div id="npc-sidebar-list" class="npc-sidebar-list"></div>
    <button type="button" class="btn btn-outline btn-small" id="npc-sidebar-manage" style="width:100%;margin-top:0.25rem;font-size:0.7rem;">Manage Library</button>
  </div>
    <p class="form-hint map-hint" style="margin-top: 0.5rem;">Click anywhere on the map to add a location<%= canAddChild ? ' or sub-map' : '' %>.<% if (showPartyMarker) { %> Drag the gold party marker to move it.<% } %></p>
  <% } %>
</div>

<!-- Add Location / Sub-Map Modal (DM only) -->
<% if (isDM) { %>
<div id="map-add-modal" class="map-add-form" style="display:none;">
  <div class="card" style="max-width: 420px; margin: 0 auto;">
    <div class="map-add-tabs">
      <button type="button" class="map-add-tab active" data-tab="location">Add Location</button>
      <% if (canAddChild) { %>
        <button type="button" class="map-add-tab" data-tab="submap">Add Sub-Map</button>
        <button type="button" class="map-add-tab" data-tab="linkmap">Link Existing</button>
      <% } %>
    </div>

    <!-- Location tab -->
    <div id="tab-location" class="map-add-tab-content">
      <form action="/map/<%= map.id %>/locations" method="POST">
        <input type="hidden" name="_csrf" value="<%= csrfToken %>">
        <input type="hidden" name="x" id="add-loc-x">
        <input type="hidden" name="y" id="add-loc-y">
        <div class="form-group">
          <label for="add-loc-name">Name</label>
          <input type="text" name="name" id="add-loc-name" required placeholder="Location name">
        </div>
        <div class="form-group">
          <label for="add-loc-desc">Description</label>
          <textarea name="description" id="add-loc-desc" rows="2" placeholder="Optional description"></textarea>
        </div>
        <div class="form-group">
          <label for="add-loc-icon">Type</label>
          <select name="icon" id="add-loc-icon">
            <% for (const [key, val] of Object.entries(MARKER_TYPES)) { %>
              <option value="<%= key %>"><%= val.icon %> <%= val.label %></option>
            <% } %>
          </select>
        </div>
        <div style="display: flex; gap: 0.5rem;">
          <button type="submit" class="btn btn-primary btn-small">Add</button>
          <button type="button" class="btn btn-outline btn-small" onclick="document.getElementById('map-add-modal').style.display='none'">Cancel</button>
        </div>
      </form>
    </div>

    <!-- Sub-Map tab -->
    <% if (canAddChild) { %>
    <div id="tab-submap" class="map-add-tab-content" style="display:none;">
      <form action="/map/<%= map.id %>/children" method="POST">
        <input type="hidden" name="_csrf" value="<%= csrfToken %>">
        <input type="hidden" name="pin_x" id="add-submap-x">
        <input type="hidden" name="pin_y" id="add-submap-y">
        <div class="form-group">
          <label for="add-submap-name">Name</label>
          <input type="text" name="name" id="add-submap-name" required placeholder="Sub-map name">
        </div>
        <div class="form-group">
          <label for="add-submap-desc">Description</label>
          <textarea name="description" id="add-submap-desc" rows="2" placeholder="Optional description"></textarea>
        </div>
        <div class="form-group">
          <label for="add-submap-type">Type</label>
          <select name="map_type" id="add-submap-type">
            <% for (const [key, val] of Object.entries(MARKER_TYPES)) { %>
              <option value="<%= key %>"><%= val.icon %> <%= val.label %></option>
            <% } %>
          </select>
        </div>
        <div style="display: flex; gap: 0.5rem;">
          <button type="submit" class="btn btn-primary btn-small">Create Sub-Map</button>
          <button type="button" class="btn btn-outline btn-small" onclick="document.getElementById('map-add-modal').style.display='none'">Cancel</button>
        </div>
      </form>
    </div>

    <div id="tab-linkmap" class="map-add-tab-content" style="display:none;">
      <div class="form-group">
        <label for="link-map-select">Select Map to Link</label>
        <select id="link-map-select" class="form-control">
          <option value="">Loading...</option>
        </select>
      </div>
      <div style="display: flex; gap: 0.5rem;">
        <button type="button" class="btn btn-primary btn-small" id="link-map-btn">Link Map</button>
        <button type="button" class="btn btn-outline btn-small" onclick="document.getElementById('map-add-modal').style.display='none'">Cancel</button>
      </div>
    </div>
    <% } %>
  </div>
</div>
<% } %>

<!-- Token Picker Modal -->
<div id="token-picker-modal" class="token-picker-modal" style="display:none;">
  <div class="card" style="max-width: 460px; margin: 0 auto;">
    <h3>Place Character Token</h3>
    <p class="form-hint">Select a character to place on this map.</p>
    <div id="token-picker-list" class="token-picker-list">
      <p class="text-muted">Loading characters...</p>
    </div>
    <div style="margin-top: 1rem;">
      <button type="button" class="btn btn-outline btn-small" onclick="document.getElementById('token-picker-modal').style.display='none'">Close</button>
    </div>
  </div>
</div>

<!-- Token Scale Panel (DM only) -->
<% if (isDM) { %>
<div id="token-scale-panel" class="token-scale-panel" style="display:none;">
  <div class="token-scale-panel-header">
    <span>Scale All Tokens</span>
    <button type="button" class="token-scale-panel-close" id="token-scale-close">&times;</button>
  </div>
  <div class="token-scale-panel-body" style="flex-direction:column;gap:0.3rem;">
    <div style="display:flex;align-items:center;justify-content:center;gap:0.5rem;">
      <button type="button" class="btn btn-small btn-outline" id="token-scale-minus" style="font-size:1rem;padding:0.2rem 0.6rem;">‚àí</button>
      <span id="token-scale-offset" style="font-size:0.9rem;min-width:3rem;text-align:center;">0.0</span>
      <button type="button" class="btn btn-small btn-outline" id="token-scale-plus" style="font-size:1rem;padding:0.2rem 0.6rem;">+</button>
    </div>
    <p class="form-hint" style="font-size:0.65rem;margin:0;text-align:center;">Adjusts all player + NPC tokens by ¬±0.1</p>
  </div>
</div>
<% } %>

<% if (isDM) { %>
<!-- Fog of War Toolbar -->
<div id="fog-toolbar" class="fog-toolbar" style="display:none;">
  <div class="fog-toolbar-header">
    <span>üå´Ô∏è Fog of War</span>
    <button type="button" class="token-scale-panel-close" id="fog-toolbar-close">&times;</button>
  </div>
  <div class="fog-toolbar-body">
    <div style="display:flex;gap:0.25rem;margin-bottom:0.5rem;">
      <button type="button" class="btn btn-small" id="fog-enable-btn"><%= map.fog_enabled ? 'Disable FoW' : 'Enable FoW' %></button>
    </div>
    <div id="fog-controls" style="<%= map.fog_enabled ? '' : 'display:none;' %>">
      <div style="display:flex;gap:0.25rem;margin-bottom:0.4rem;">
        <button type="button" class="btn btn-small btn-primary fog-brush-btn active" data-brush="reveal">Reveal</button>
        <button type="button" class="btn btn-small btn-outline fog-brush-btn" data-brush="hide">Hide</button>
      </div>
      <div style="margin-bottom:0.4rem;">
        <label style="font-size:0.7rem;color:var(--text-secondary);">Brush: <span id="fog-brush-size-val">5</span>%</label>
        <input type="range" id="fog-brush-size" min="1" max="20" value="5" style="width:100%;">
      </div>
      <div style="display:flex;gap:0.25rem;flex-wrap:wrap;">
        <button type="button" class="btn btn-small btn-primary" id="fog-publish-btn">Publish</button>
        <button type="button" class="btn btn-small btn-outline" id="fog-reset-btn">Reset Draft</button>
      </div>
      <p class="form-hint" style="margin-top:0.3rem;font-size:0.65rem;">Click & drag on map to reveal/hide areas. Publish to show players.</p>
    </div>
  </div>
</div>
<% } %>


<% if (isDM) { %>
<!-- NPC Picker Modal -->
<div id="npc-picker-modal" class="token-picker-modal" style="display:none;">
  <div class="card" style="max-width: 520px; margin: 0 auto;">
    <div style="display: flex; justify-content: space-between; align-items: center;">
      <h3>Place NPC Token</h3>
      <button type="button" class="btn btn-outline btn-small" id="npc-library-btn" style="font-size: 0.75rem;">Manage Library</button>
    </div>
    <p class="form-hint">Select an NPC to place on this map.</p>
    <input type="text" id="npc-picker-search" placeholder="Search NPCs..." style="width:100%; margin-bottom: 0.5rem; padding: 0.4rem 0.6rem; background: var(--bg-input); border: 1px solid var(--border); border-radius: var(--radius); color: var(--text-primary); font-size: 0.85rem;">
    <div id="npc-picker-list" class="token-picker-list">
      <p class="text-muted">Loading NPCs...</p>
    </div>
    <div style="margin-top: 1rem;">
      <button type="button" class="btn btn-outline btn-small" onclick="document.getElementById('npc-picker-modal').style.display='none'">Close</button>
    </div>
  </div>
</div>

<!-- NPC Library Management Modal -->
<div id="npc-library-modal" class="condition-picker-overlay" style="display:none;">
  <div class="card condition-picker-card" style="max-width: 560px; width: 95%; max-height: 85vh;">
    <h3>NPC Library</h3>
    <div style="display: flex; gap: 0.5rem; margin-bottom: 0.75rem;">
      <button type="button" class="btn btn-primary btn-small" id="npc-create-btn">+ New NPC</button>
      <button type="button" class="btn btn-outline btn-small" id="npc-cat-manage-btn">Categories</button>
    </div>

    <!-- Category management (hidden by default) -->
    <div id="npc-cat-section" style="display:none; margin-bottom: 0.75rem; padding: 0.5rem; background: var(--bg-darker); border-radius: var(--radius);">
      <div style="display:flex; gap:0.5rem; margin-bottom:0.5rem;">
        <input type="text" id="npc-new-cat-name" placeholder="New category name" style="flex:1; padding:0.3rem 0.5rem; background: var(--bg-input); border: 1px solid var(--border); border-radius: var(--radius); color: var(--text-primary); font-size: 0.8rem;">
        <button type="button" class="btn btn-primary btn-small" id="npc-add-cat-btn" style="font-size:0.75rem;">Add</button>
      </div>
      <div id="npc-cat-list"></div>
    </div>

    <!-- Create/Edit NPC form (hidden by default) -->
    <div id="npc-form-section" style="display:none; margin-bottom: 0.75rem; padding: 0.5rem; background: var(--bg-darker); border-radius: var(--radius);">
      <h4 id="npc-form-title" style="margin-bottom: 0.5rem;">Create NPC</h4>
      <!-- Source selector: import from Vault or create custom -->
      <div id="npc-source-section" style="margin-bottom: 0.5rem;">
        <label style="font-size: 0.8rem;">Source</label>
        <div style="display:flex; gap: 0.25rem; flex-wrap: wrap; margin-top: 0.25rem;">
          <button type="button" class="btn btn-small btn-primary npc-source-btn active" data-source="custom">Custom</button>
          <button type="button" class="btn btn-small btn-outline npc-source-btn" data-source="bestiary">Bestiary</button>
        </div>
        <!-- Search from Vault -->
        <div id="npc-vault-search" style="display:none; margin-top: 0.4rem;">
          <div style="display:flex; gap:0.35rem;">
            <input type="text" id="npc-vault-query" placeholder="Search..." style="flex:1; padding:0.3rem 0.5rem; background: var(--bg-input); border: 1px solid var(--border); border-radius: var(--radius); color: var(--text-primary); font-size: 0.8rem;">
            <button type="button" class="btn btn-small btn-outline" id="npc-vault-search-btn">Search</button>
          </div>
          <div id="npc-vault-results" style="max-height: 150px; overflow-y: auto; margin-top: 0.3rem;"></div>
        </div>
      </div>
      <form id="npc-form" enctype="multipart/form-data">
        <input type="hidden" id="npc-form-id" value="">
        <input type="hidden" id="npc-form-source-type" value="custom">
        <input type="hidden" id="npc-form-source-key" value="">
        <div class="form-group" style="margin-bottom: 0.4rem;">
          <label style="font-size: 0.8rem;">Name *</label>
          <input type="text" name="name" id="npc-form-name" required placeholder="NPC name" style="padding: 0.3rem 0.5rem; font-size: 0.85rem;">
        </div>
        <div style="display:flex; gap:0.5rem; align-items:flex-start;">
          <div class="form-group" style="flex:1; margin-bottom: 0.4rem;">
            <label style="font-size: 0.8rem;">Categories</label>
            <div id="npc-form-cats" style="display:flex; flex-wrap:wrap; gap:0.25rem; max-height:80px; overflow-y:auto;"></div>
          </div>
          <div class="form-group" style="width: 90px; margin-bottom: 0.4rem;">
            <label style="font-size: 0.8rem;">Max HP</label>
            <input type="number" name="max_hp" id="npc-form-hp" min="0" value="0" style="width: 100%; padding: 0.3rem 0.4rem; font-size: 0.85rem; background: var(--bg-input); border: 1px solid var(--border); border-radius: var(--radius); color: var(--text-primary); font-family: 'Crimson Text', serif;">
          </div>
        </div>
        <div class="form-group" style="margin-bottom: 0.4rem;">
          <label style="font-size: 0.8rem;">Avatar</label>
          <div id="npc-avatar-auto-section" style="display:none; margin-bottom: 0.35rem;">
            <button type="button" id="npc-fetch-avatar-btn" class="btn btn-outline btn-small" style="font-size: 0.75rem; width: 100%;">Fetch avatar from D&amp;D 5e SRD</button>
            <div id="npc-fetch-avatar-status" style="font-size: 0.75rem; color: var(--text-secondary); margin-top: 0.2rem;"></div>
          </div>
          <input type="file" name="avatar" id="npc-form-avatar" accept="image/*" style="font-size: 0.8rem;">
          <div id="npc-form-avatar-preview" style="margin-top:0.25rem;"></div>
        </div>
        <div class="form-group" style="margin-bottom: 0.4rem;">
          <label style="font-size: 0.8rem;">Notes</label>
          <textarea name="notes" id="npc-form-notes" rows="2" style="padding: 0.3rem 0.5rem; font-size: 0.85rem;" placeholder="Optional notes"></textarea>
        </div>
        <div style="display:flex; gap:0.5rem;">
          <button type="submit" class="btn btn-primary btn-small">Save</button>
          <button type="button" class="btn btn-outline btn-small" onclick="document.getElementById('npc-form-section').style.display='none'">Cancel</button>
        </div>
      </form>
    </div>

    <!-- NPC List -->
    <div id="npc-library-list" style="max-height: 350px; overflow-y: auto;">
      <p class="text-muted">Loading...</p>
    </div>

    <div style="margin-top: 0.75rem;">
      <button type="button" class="btn btn-outline btn-small" onclick="document.getElementById('npc-library-modal').style.display='none'">Close</button>
    </div>
  </div>
</div>
<% } %>

<% if (isDM) { %>
<div id="map-edit-modal" class="map-add-form" style="display:none;">
  <div class="card" style="max-width: 400px; margin: 0 auto;">
    <h3>Edit Location</h3>
    <form id="edit-loc-form" method="POST">
      <input type="hidden" name="_csrf" value="<%= csrfToken %>">
      <div class="form-group">
        <label for="edit-loc-name">Name</label>
        <input type="text" name="name" id="edit-loc-name" required>
      </div>
      <div class="form-group">
        <label for="edit-loc-desc">Description</label>
        <textarea name="description" id="edit-loc-desc" rows="2"></textarea>
      </div>
      <div class="form-group">
        <label for="edit-loc-icon">Type</label>
        <select name="icon" id="edit-loc-icon">
          <% for (const [key, val] of Object.entries(MARKER_TYPES)) { %>
            <option value="<%= key %>"><%= val.icon %> <%= val.label %></option>
          <% } %>
        </select>
      </div>
      <div style="display: flex; gap: 0.5rem;">
        <button type="submit" class="btn btn-primary btn-small">Save</button>
        <button type="button" class="btn btn-outline btn-small" onclick="document.getElementById('map-edit-modal').style.display='none'">Cancel</button>
      </div>
    </form>
  </div>
</div>
<% } %>

<% if (locations.length > 0) { %>
<div class="card" style="margin-top: 1rem;">
  <h2>Locations</h2>
  <div class="admin-table-wrapper">
    <table class="admin-table">
      <thead>
        <tr>
          <th style="width:2rem;"></th>
          <th>Name</th>
          <th>Description</th>
          <th>Type</th>
          <% if (isDM) { %><th>Actions</th><% } %>
        </tr>
      </thead>
      <tbody>
        <% for (const loc of locations) { %>
          <tr>
            <td>
              <button type="button" class="btn-map-pin" data-center-loc="<%= loc.id %>" title="Center map on this location">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path><circle cx="12" cy="10" r="3"></circle></svg>
              </button>
            </td>
            <td><strong><%= loc.name %></strong></td>
            <td class="text-muted"><%= loc.description || '‚Äî' %></td>
            <td><span class="map-marker-badge map-marker-<%= loc.icon %>"><%= MARKER_TYPES[loc.icon] ? MARKER_TYPES[loc.icon].icon + ' ' + MARKER_TYPES[loc.icon].label : loc.icon %></span></td>
            <% if (isDM) { %>
              <td>
                <div style="display: flex; gap: 0.25rem;">
                  <button type="button" class="btn btn-small btn-outline" data-table-edit-loc="<%= loc.id %>">Edit</button>
                  <% if (canAddChild) { %>
                    <form action="/map/<%= map.id %>/locations/<%= loc.id %>/convert" method="POST" class="inline-form">
                      <input type="hidden" name="_csrf" value="<%= csrfToken %>">
                      <button type="submit" class="btn btn-small btn-outline" onclick="return confirm('Convert this location to a sub-map?')" title="Convert to sub-map">
                        <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2"/><path d="M3 9h18"/><path d="M9 21V9"/></svg>
                      </button>
                    </form>
                  <% } %>
                  <form action="/map/<%= map.id %>/locations/<%= loc.id %>/delete" method="POST" class="inline-form">
      <input type="hidden" name="_csrf" value="<%= csrfToken %>">
                    <button type="submit" class="btn btn-small btn-danger" onclick="return confirm('Delete this location?')">&times;</button>
                  </form>
                </div>
              </td>
            <% } %>
          </tr>
        <% } %>
      </tbody>
    </table>
  </div>
</div>
<% } %>

<% if (children.length > 0) { %>
<div class="card" style="margin-top: 1rem;">
  <h2>Sub-Maps</h2>
  <div class="admin-table-wrapper">
    <table class="admin-table">
      <thead>
        <tr>
          <th style="width:2rem;"></th>
          <th>Name</th>
          <th>Description</th>
          <th>Type</th>
          <% if (isDM) { %><th>Actions</th><% } %>
        </tr>
      </thead>
      <tbody>
        <% for (const child of children) { %>
          <tr>
            <td>
              <button type="button" class="btn-map-pin" data-center-child="<%= child.id %>" title="Center map on this sub-map">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path><circle cx="12" cy="10" r="3"></circle></svg>
              </button>
            </td>
            <td><a href="/map/<%= child.id %>" style="color: var(--gold); font-weight: 600;"><%= child.name %></a></td>
            <td class="text-muted"><%= child.description || '‚Äî' %></td>
            <td><span class="map-marker-badge map-marker-<%= child.map_type %>"><%= MARKER_TYPES[child.map_type] ? MARKER_TYPES[child.map_type].icon + ' ' + MARKER_TYPES[child.map_type].label : child.map_type %></span></td>
            <% if (isDM) { %>
              <td>
                <div style="display: flex; gap: 0.25rem;">
                  <form action="/map/<%= child.id %>/delete" method="POST" class="inline-form">
                    <input type="hidden" name="_csrf" value="<%= csrfToken %>">
                    <button type="submit" class="btn btn-small btn-danger" onclick="return confirm('Delete this sub-map and all its children?')">&times;</button>
                  </form>
                </div>
              </td>
            <% } %>
          </tr>
        <% } %>
        <% if (typeof mapLinks !== 'undefined') { for (const link of mapLinks) { %>
          <tr>
            <td>
              <button type="button" class="btn-map-pin" data-center-link="<%= link.id %>" data-link-x="<%= link.pin_x %>" data-link-y="<%= link.pin_y %>" title="Center map on this link">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path><circle cx="12" cy="10" r="3"></circle></svg>
              </button>
            </td>
            <td><a href="/map/<%= link.target_map_id %>" style="color: var(--gold); font-weight: 600;"><%= link.name %></a> <span style="font-size:0.65rem;color:var(--text-secondary);">üîó</span></td>
            <td class="text-muted"><%= link.description || '‚Äî' %></td>
            <td><span class="map-marker-badge map-marker-<%= link.map_type %>"><%= MARKER_TYPES[link.map_type] ? MARKER_TYPES[link.map_type].icon + ' ' + MARKER_TYPES[link.map_type].label : link.map_type %></span></td>
            <% if (isDM) { %>
              <td>
                <div style="display: flex; gap: 0.25rem;">
                  <button type="button" class="btn btn-small btn-danger" onclick="unlinkMap(<%= link.id %>)">&times;</button>
                </div>
              </td>
            <% } %>
          </tr>
        <% } } %>
      </tbody>
    </table>
  </div>
</div>
<% } %>

<script>
(function() {
  var locations = <%- JSON.stringify(locations) %>;
  var mapData = <%- JSON.stringify(map) %>;
  var childMaps = <%- JSON.stringify(children) %>;
  var mapLinksData = <%- JSON.stringify(typeof mapLinks !== 'undefined' ? mapLinks : []) %>;
  var tokensData = <%- JSON.stringify(tokens) %>;
  var npcTokensData = <%- JSON.stringify(typeof npcTokens !== 'undefined' ? npcTokens : []) %>;
  var isDM = <%= isDM ? 'true' : 'false' %>;
  var showPartyMarker = <%= showPartyMarker ? 'true' : 'false' %>;
  var currentUserId = <%= currentUserId %>;
  var mapImagePath = mapData.image_path ? '/maps/' + mapData.image_path : null;
  var csrfToken = '<%= csrfToken %>';

  // MARKER_ICONS already defined above

  function initMap(imgW, imgH) {

  var leafletMap = L.map('map-container', {
    crs: L.CRS.Simple,
    minZoom: -3,
    maxZoom: 3,
    zoomSnap: 0.25,
    attributionControl: false
  });

  var bounds = [[0, 0], [imgH, imgW]];

  if (mapImagePath) {
    L.imageOverlay(mapImagePath, bounds).addTo(leafletMap);
  } else {
    var svgPlaceholder = '<svg xmlns="http://www.w3.org/2000/svg" width="1000" height="700" viewBox="0 0 1000 700">'
      + '<rect fill="#d4c5a9" width="1000" height="700"/>'
      + '<rect fill="#c4b594" x="20" y="20" width="960" height="660" rx="8"/>'
      + '<text x="500" y="320" font-family="serif" font-size="48" fill="#8b7355" text-anchor="middle">Your World Awaits</text>'
      + '<text x="500" y="380" font-family="serif" font-size="20" fill="#a89878" text-anchor="middle">Upload a map image to get started</text>'
      + '</svg>';
    var svgUrl = 'data:image/svg+xml;base64,' + btoa(svgPlaceholder);
    L.imageOverlay(svgUrl, bounds).addTo(leafletMap);
  }

  leafletMap.fitBounds(bounds);

  var MARKER_ICONS = <%- JSON.stringify(MARKER_TYPES) %>;
  var iconColors = { pin: '#c0392b', overworld: '#27ae60', city: '#2980b9', location: '#e67e22', tavern: '#27ae60', dungeon: '#8e44ad', secret: '#9b59b6' };

  function makeIcon(type) {
    var emoji = (MARKER_ICONS[type] && MARKER_ICONS[type].icon) || 'üìå';
    var color = iconColors[type] || iconColors.pin;
    return L.divIcon({
      className: 'map-marker-icon',
      html: '<div class="map-loc-pin" style="border-color:' + color + ';">' + emoji + '</div>',
      iconSize: [26, 26],
      iconAnchor: [13, 13]
    });
  }

  function pctToLatLng(x, y) {
    return [imgH * (1 - y / 100), imgW * x / 100];
  }

  function latLngToPct(latlng) {
    return { x: (latlng.lng / imgW) * 100, y: (1 - latlng.lat / imgH) * 100 };
  }

  function escHtml(s) {
    var d = document.createElement('div');
    d.textContent = s;
    return d.innerHTML;
  }

  // ---- Location markers ----
  var locById = {};
  locations.forEach(function(loc) { locById[loc.id] = loc; });

  locations.forEach(function(loc) {
    var ll = pctToLatLng(loc.x, loc.y);
    var marker = L.marker(ll, { icon: makeIcon(loc.icon) }).addTo(leafletMap);
    var popupContent = '<strong>' + escHtml(loc.name) + '</strong>';
    if (loc.description) popupContent += '<br>' + escHtml(loc.description);
    if (isDM) {
      popupContent += '<div style="margin-top:0.5rem; display:flex; gap:0.25rem;">'
        + '<button type="button" class="btn btn-small btn-outline" data-edit-loc="' + loc.id + '" style="font-size:0.75rem;padding:0.2rem 0.5rem;">Edit</button>'
        + '<form action="/map/<%= map.id %>/locations/' + loc.id + '/delete" method="POST">'
      + '<input type="hidden" name="_csrf" value="<%= csrfToken %>">'
        + '<button type="submit" class="btn btn-small btn-danger" onclick="return confirm(\'Delete this location?\')" style="font-size:0.75rem;padding:0.2rem 0.5rem;">Delete</button></form>'
        + '</div>';
    }
    var popup = L.popup().setContent(popupContent);
    marker.bindPopup(popup);
    marker.on('popupopen', function() {
      var editBtn = document.querySelector('[data-edit-loc="' + loc.id + '"]');
      if (editBtn) {
        editBtn.addEventListener('click', function() {
          var l = locById[loc.id];
          openEditLocation(l.id, l.name, l.description || '', l.icon);
        });
      }
    });
  });

  // ---- Child map pins ----
  childMaps.forEach(function(child) {
    var ll = pctToLatLng(child.pin_x || 50, child.pin_y || 50);
    var typeInfo = MARKER_ICONS[child.map_type] || { icon: 'üìç', label: child.map_type };
    var childIcon = L.divIcon({
      className: 'map-child-pin',
      html: '<div class="map-child-pin-icon">' + typeInfo.icon + '</div>',
      iconSize: [28, 28],
      iconAnchor: [14, 14]
    });
    var childMarker = L.marker(ll, { icon: childIcon, draggable: isDM }).addTo(leafletMap);
    var childPopup = '<div style="text-align:center;">'
      + '<strong>' + escHtml(child.name) + '</strong><br>'
      + '<span class="map-type-badge map-type-' + child.map_type + '" style="font-size:0.7rem;">' + typeInfo.icon + ' ' + typeInfo.label + '</span><br>'
      + '<a href="/map/' + child.id + '" class="btn btn-primary btn-small" style="margin-top:0.5rem;font-size:0.75rem;">Enter Map</a>'
      + '</div>';
    childMarker.bindPopup(childPopup);

    if (isDM) {
      childMarker.on('dragend', function() {
        var pct = latLngToPct(childMarker.getLatLng());
        fetch('/map/<%= map.id %>/children/' + child.id + '/pin', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', 'X-CSRF-Token': csrfToken },
          body: JSON.stringify({ x: pct.x, y: pct.y })
        });
      });
    }
  });

  // ---- Map links (non-hierarchical hyperlinks) ----
  mapLinksData.forEach(function(link) {
    var ll = pctToLatLng(link.pin_x || 50, link.pin_y || 50);
    var typeInfo = MARKER_ICONS[link.map_type] || { icon: 'üìç', label: link.map_type };
    var linkIcon = L.divIcon({
      className: 'map-child-pin map-link-pin',
      html: '<div class="map-child-pin-icon" style="border-color:var(--gold);">' + typeInfo.icon + '</div>',
      iconSize: [28, 28],
      iconAnchor: [14, 14]
    });
    var linkMarker = L.marker(ll, { icon: linkIcon, draggable: isDM }).addTo(leafletMap);
    var linkPopup = '<div style="text-align:center;">'
      + '<strong>' + escHtml(link.name) + '</strong><br>'
      + '<span class="map-type-badge map-type-' + link.map_type + '" style="font-size:0.7rem;">' + typeInfo.icon + ' ' + typeInfo.label + '</span>'
      + '<br><span style="font-size:0.6rem;color:var(--text-secondary);">üîó Linked Map</span><br>'
      + '<a href="/map/' + link.target_map_id + '" class="btn btn-primary btn-small" style="margin-top:0.5rem;font-size:0.75rem;">Go to Map</a>'
      + (isDM ? '<br><button class="btn btn-danger btn-small" style="margin-top:0.25rem;font-size:0.65rem;" onclick="unlinkMap(' + link.id + ')">Unlink</button>' : '')
      + '</div>';
    linkMarker.bindPopup(linkPopup);

    if (isDM) {
      linkMarker.on('dragend', function() {
        var pct = latLngToPct(linkMarker.getLatLng());
        fetch('/map/<%= map.id %>/links/' + link.id + '/pin', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', 'X-CSRF-Token': csrfToken },
          body: JSON.stringify({ x: pct.x, y: pct.y })
        });
      });
    }
  });

  // ---- Party marker (top-level only) ----
  if (showPartyMarker) {
    var partyX = mapData.party_x || 50;
    var partyY = mapData.party_y || 50;
    var partyLL = pctToLatLng(partyX, partyY);
    var partyIcon = L.divIcon({
      className: 'map-marker-icon',
      html: '<div class="map-party-marker"></div>',
      iconSize: [18, 18],
      iconAnchor: [9, 9]
    });
    var partyMarker = L.marker(partyLL, { icon: partyIcon, draggable: isDM }).addTo(leafletMap);
    partyMarker.bindPopup('<strong>Party Location</strong>');

    if (isDM) {
      partyMarker.on('dragend', function() {
        var pct = latLngToPct(partyMarker.getLatLng());
        fetch('/map/<%= map.id %>/party', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', 'X-CSRF-Token': csrfToken },
          body: JSON.stringify({ x: pct.x, y: pct.y })
        });
      });
    }
  }

  // ---- Condition colors & icons ----
  var CONDITION_COLORS = {
    'Blinded': '#555', 'Charmed': '#ff69b4', 'Deafened': '#888', 'Exhaustion': '#8B4513',
    'Frightened': '#9B59B6', 'Grappled': '#e67e22', 'Incapacitated': '#95a5a6',
    'Invisible': '#ecf0f1', 'Paralyzed': '#f1c40f', 'Petrified': '#7f8c8d',
    'Poisoned': '#27ae60', 'Prone': '#d35400', 'Restrained': '#8B6914',
    'Stunned': '#f39c12', 'Unconscious': '#2c3e50'
  };
  var CONDITION_ICONS = {
    'Blinded': 'üï∂Ô∏è', 'Charmed': 'üíï', 'Deafened': 'üîá', 'Exhaustion': 'üò´',
    'Frightened': 'üò±', 'Grappled': 'ü§º', 'Incapacitated': 'üí´',
    'Invisible': 'üëª', 'Paralyzed': '‚ö°', 'Petrified': 'ü™®',
    'Poisoned': '‚ò†Ô∏è', 'Prone': '‚¨áÔ∏è', 'Restrained': '‚õìÔ∏è',
    'Stunned': 'üí•', 'Unconscious': 'üí§'
  };

  function hashColor(str) {
    var hash = 0;
    for (var i = 0; i < str.length; i++) hash = str.charCodeAt(i) + ((hash << 5) - hash);
    var h = Math.abs(hash) % 360;
    return 'hsl(' + h + ', 60%, 45%)';
  }

  function getCondColor(name) { return CONDITION_COLORS[name] || hashColor(name); }
  function getCondIcon(name) { return CONDITION_ICONS[name] || '‚ö†Ô∏è'; }

  function triggerCondEntrance(marker) {
    // Find the marker's DOM element and add entrance class to badges
    setTimeout(function() {
      var el = marker.getElement();
      if (!el) return;
      el.querySelectorAll('.token-condition-badge').forEach(function(badge) {
        badge.classList.add('cond-enter');
        badge.addEventListener('animationend', function handler(e) {
          if (e.animationName === 'conditionEntrance') {
            badge.classList.remove('cond-enter');
            badge.removeEventListener('animationend', handler);
          }
        });
      });
    }, 50);
  }

  // ---- Character tokens ----
  var tokenMarkers = {};

  function makeTokenIcon(token) {
    var scale = token.scale || 1.0;
    var avatarSize = Math.round(28 * scale);
    var avatarHtml;
    if (token.char_avatar) {
      avatarHtml = '<img src="' + escHtml(token.char_avatar) + '" alt="" class="map-token-avatar" style="width:' + avatarSize + 'px;height:' + avatarSize + 'px;">';
    } else {
      avatarHtml = '<div class="map-token-avatar map-token-no-avatar" style="width:' + avatarSize + 'px;height:' + avatarSize + 'px;font-size:' + (0.75 * scale) + 'rem;">' + escHtml(token.char_name.charAt(0).toUpperCase()) + '</div>';
    }

    // Condition badges ‚Äî deduplicate by condition_name
    var condHtml = '';
    var conditions = token.conditions || [];
    var seen = {};
    conditions = conditions.filter(function(c) {
      if (seen[c.condition_name]) return false;
      seen[c.condition_name] = true;
      return true;
    });
    token.conditions = conditions;
    if (conditions.length > 0) {
      var hasCondClass = ' has-conditions';
      var maxShow = 4;
      condHtml = '<div class="token-conditions">';
      for (var i = 0; i < Math.min(conditions.length, maxShow); i++) {
        var c = conditions[i];
        var color = getCondColor(c.condition_name);
        condHtml += '<div class="token-condition-badge" style="background:' + color + ';" title="' + escHtml(c.condition_name) + '">' + getCondIcon(c.condition_name) + '</div>';
      }
      if (conditions.length > maxShow) {
        condHtml += '<div class="token-condition-badge token-condition-overflow">+' + (conditions.length - maxShow) + '</div>';
      }
      condHtml += '</div>';
      // Add glow via style on avatar
      var glowColor = getCondColor(conditions[0].condition_name);
      if (token.char_avatar) {
        avatarHtml = '<img src="' + escHtml(token.char_avatar) + '" alt="" class="map-token-avatar has-conditions" style="width:' + avatarSize + 'px;height:' + avatarSize + 'px;--condition-color:' + glowColor + ';">';
      } else {
        avatarHtml = '<div class="map-token-avatar map-token-no-avatar has-conditions" style="width:' + avatarSize + 'px;height:' + avatarSize + 'px;font-size:' + (0.75 * scale) + 'rem;--condition-color:' + glowColor + ';">' + escHtml(token.char_name.charAt(0).toUpperCase()) + '</div>';
      }
    }

    var iconW = Math.max(40, Math.round(28 * scale) + 12);
    var iconH = Math.round(avatarSize + 22);

    return L.divIcon({
      className: 'map-token',
      html: '<div class="map-token-wrapper">' + avatarHtml + condHtml + '<div class="map-token-label">' + escHtml(token.char_name) + '</div></div>',
      iconSize: [iconW, iconH],
      iconAnchor: [iconW / 2, iconH / 2]
    });
  }

  function canMoveToken(token) {
    return token.char_owner === currentUserId || isDM;
  }

  function buildTokenPopup(token) {
    var popupHtml = '<div style="text-align:center;">'
      + '<strong>' + escHtml(token.char_name) + '</strong><br>'
      + '<span class="text-muted" style="font-size:0.75rem;">Player: ' + escHtml(token.owner_name) + '</span>';

    // Conditions list
    var conditions = token.conditions || [];
    if (conditions.length > 0 || isDM) {
      popupHtml += '<div class="token-popup-conditions" style="margin-top:0.4rem;">';
      if (conditions.length > 0) {
        popupHtml += '<div style="display:flex;flex-wrap:wrap;gap:3px;justify-content:center;margin-bottom:0.3rem;">';
        conditions.forEach(function(c) {
          var color = getCondColor(c.condition_name);
          popupHtml += '<span class="token-popup-cond-badge" style="background:' + color + ';">' + getCondIcon(c.condition_name) + ' ' + escHtml(c.condition_name);
          if (isDM) {
            popupHtml += ' <span class="token-popup-cond-remove" data-remove-cond="' + c.id + '" data-token-id="' + token.id + '">&times;</span>';
          }
          popupHtml += '</span>';
        });
        popupHtml += '</div>';
      }
      if (isDM) {
        popupHtml += '<button type="button" class="btn btn-small btn-outline" data-add-condition="' + token.id + '" style="font-size:0.7rem;padding:0.15rem 0.4rem;">+ Condition</button>';
      }
      popupHtml += '</div>';
    }

    // Resize slider (DM only)
    if (isDM) {
      popupHtml += '<div style="margin-top:0.4rem;"><label style="font-size:0.7rem;color:var(--text-secondary);">Size: <span id="resize-val-' + token.id + '">' + (token.scale || 1.0).toFixed(1) + 'x</span></label>'
        + '<input type="range" min="0.5" max="3.0" step="0.1" value="' + (token.scale || 1.0) + '" data-resize-token="' + token.id + '" style="width:100%;margin:0.2rem 0;">'
        + '</div>';
    }

    if (canMoveToken(token)) {
      popupHtml += '<br><button type="button" class="btn btn-small btn-danger" data-remove-token="' + token.id + '" style="font-size:0.75rem;">Remove</button>';
    }
    popupHtml += '</div>';
    return popupHtml;
  }

  function bindTokenPopup(marker, token) {
    marker.bindPopup(buildTokenPopup(token), { maxWidth: 250 });

    marker.on('popupopen', function() {
      // Remove token button
      var removeBtn = document.querySelector('[data-remove-token="' + token.id + '"]');
      if (removeBtn) {
        removeBtn.addEventListener('click', function() {
          fetch('/map/<%= map.id %>/tokens/' + token.id + '/delete', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'X-CSRF-Token': csrfToken }
          }).then(function(r) { return r.json(); }).then(function(d) {
            if (d.success) {
              leafletMap.removeLayer(marker);
              delete tokenMarkers[token.id];
            }
          });
        });
      }

      // Resize slider
      var resizeSlider = document.querySelector('[data-resize-token="' + token.id + '"]');
      if (resizeSlider) {
        resizeSlider.addEventListener('input', function() {
          var val = parseFloat(this.value);
          document.getElementById('resize-val-' + token.id).textContent = val.toFixed(1) + 'x';
        });
        resizeSlider.addEventListener('change', function() {
          var val = parseFloat(this.value);
          token.scale = val;
          marker.setIcon(makeTokenIcon(token));
          fetch('/map/<%= map.id %>/tokens/' + token.id + '/resize', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'X-CSRF-Token': csrfToken },
            body: JSON.stringify({ scale: val })
          });
        });
      }

      // Add condition button
      var addCondBtn = document.querySelector('[data-add-condition="' + token.id + '"]');
      if (addCondBtn) {
        addCondBtn.addEventListener('click', function() {
          openConditionPicker(token, marker);
        });
      }

      // Remove condition buttons
      document.querySelectorAll('[data-remove-cond]').forEach(function(btn) {
        if (parseInt(btn.getAttribute('data-token-id')) === token.id) {
          btn.addEventListener('click', function(e) {
            e.stopPropagation();
            var condId = btn.getAttribute('data-remove-cond');
            fetch('/map/<%= map.id %>/tokens/' + token.id + '/conditions/' + condId + '/delete', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json', 'X-CSRF-Token': csrfToken }
            }).then(function(r) { return r.json(); }).then(function(d) {
              if (d.success) {
                token.conditions = token.conditions.filter(function(c) { return c.id !== parseInt(condId); });
                marker.setIcon(makeTokenIcon(token));
                marker.closePopup(); marker.unbindPopup(); marker.bindPopup(buildTokenPopup(token), { maxWidth: 220 }); marker.openPopup();
              }
            });
          });
        }
      });
    });
  }

  tokensData.forEach(function(token) {
    var ll = pctToLatLng(token.x, token.y);
    var draggable = canMoveToken(token);
    var marker = L.marker(ll, { icon: makeTokenIcon(token), draggable: draggable }).addTo(leafletMap);
    tokenMarkers[token.id] = marker;

    bindTokenPopup(marker, token);

    if (draggable) {
      marker.on('dragend', function() {
        var pct = latLngToPct(marker.getLatLng());
        fetch('/map/<%= map.id %>/tokens/' + token.id + '/move', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', 'X-CSRF-Token': csrfToken },
          body: JSON.stringify({ x: pct.x, y: pct.y })
        });
      });
    }
  });

  // ---- Token Picker ----
  document.getElementById('token-picker-btn').addEventListener('click', function() {
    var modal = document.getElementById('token-picker-modal');
    var list = document.getElementById('token-picker-list');
    modal.style.display = 'block';
    list.innerHTML = '<p class="text-muted">Loading characters...</p>';

    fetch('/map/<%= map.id %>/characters')
      .then(function(r) { return r.json(); })
      .then(function(data) {
        if (!data.characters || data.characters.length === 0) {
          list.innerHTML = '<p class="text-muted">No characters found. Create characters in your profile first.</p>';
          return;
        }

        // Group by user
        var byUser = {};
        data.characters.forEach(function(c) {
          if (!byUser[c.username]) byUser[c.username] = [];
          byUser[c.username].push(c);
        });

        // Check which characters are already on map
        var onMap = {};
        tokensData.forEach(function(t) { onMap[t.character_id] = true; });

        var html = '';
        for (var username in byUser) {
          html += '<div class="token-picker-group"><div class="token-picker-group-label">' + escHtml(username) + '</div>';
          byUser[username].forEach(function(c) {
            var alreadyPlaced = onMap[c.id];
            var canPlace = (c.user_id === currentUserId || isDM) && !alreadyPlaced;
            var avatarHtml = c.avatar
              ? '<img src="' + escHtml(c.avatar) + '" alt="" class="token-picker-avatar">'
              : '<div class="token-picker-avatar token-picker-no-avatar">' + escHtml(c.name.charAt(0).toUpperCase()) + '</div>';
            html += '<button type="button" class="token-picker-item' + (!canPlace ? ' disabled' : '') + '" ' + (canPlace ? 'data-place-char="' + c.id + '" data-char-name="' + escHtml(c.name) + '" data-char-avatar="' + escHtml(c.avatar || '') + '" data-char-owner="' + c.user_id + '" data-char-username="' + escHtml(c.username) + '"' : 'disabled') + '>'
              + avatarHtml
              + '<span class="token-picker-name">' + escHtml(c.name) + '</span>'
              + (alreadyPlaced ? '<span class="token-picker-placed">On Map</span>' : '')
              + '</button>';
          });
          html += '</div>';
        }
        list.innerHTML = html;

        // Bind click handlers
        list.querySelectorAll('[data-place-char]').forEach(function(btn) {
          btn.addEventListener('click', function() {
            var charId = parseInt(btn.getAttribute('data-place-char'));
            var charName = btn.getAttribute('data-char-name');
            var charAvatar = btn.getAttribute('data-char-avatar');
            var charOwner = parseInt(btn.getAttribute('data-char-owner'));
            var charUsername = btn.getAttribute('data-char-username');

            // Place at map center
            var center = leafletMap.getCenter();
            var pct = latLngToPct(center);

            fetch('/map/<%= map.id %>/tokens', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json', 'X-CSRF-Token': csrfToken },
              body: JSON.stringify({ character_id: charId, x: pct.x, y: pct.y })
            }).then(function(r) { return r.json(); }).then(function(d) {
              if (d.success) {
                var newToken = {
                  id: d.tokenId,
                  character_id: charId,
                  char_name: charName,
                  char_avatar: charAvatar,
                  char_owner: charOwner,
                  owner_name: charUsername,
                  x: pct.x,
                  y: pct.y
                };
                tokensData.push(newToken);
                addTokenMarker(newToken);
                onMap[charId] = true;
                btn.classList.add('disabled');
                btn.disabled = true;
                var placedSpan = document.createElement('span');
                placedSpan.className = 'token-picker-placed';
                placedSpan.textContent = 'On Map';
                btn.appendChild(placedSpan);
              } else if (d.error) {
                alert(d.error);
              }
            });
          });
        });
      });
  });

  function addTokenMarker(token) {
    token.conditions = token.conditions || [];
    token.scale = token.scale || 1.0;
    var ll = pctToLatLng(token.x, token.y);
    var draggable = canMoveToken(token);
    var marker = L.marker(ll, { icon: makeTokenIcon(token), draggable: draggable }).addTo(leafletMap);
    tokenMarkers[token.id] = marker;

    bindTokenPopup(marker, token);

    if (draggable) {
      marker.on('dragend', function() {
        var pct = latLngToPct(marker.getLatLng());
        fetch('/map/<%= map.id %>/tokens/' + token.id + '/move', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', 'X-CSRF-Token': csrfToken },
          body: JSON.stringify({ x: pct.x, y: pct.y })
        });
      });
    }
    if (isDM && typeof addMultiSelectToMarker === 'function') addMultiSelectToMarker(marker, 'player', token.id, token);
  }

  // ---- DM: Click to add location/submap ----
  if (isDM) {
    leafletMap.on('click', function(e) {
      var pct = latLngToPct(e.latlng);
      if (pct.x < 0 || pct.x > 100 || pct.y < 0 || pct.y > 100) return;
      document.getElementById('add-loc-x').value = pct.x.toFixed(2);
      document.getElementById('add-loc-y').value = pct.y.toFixed(2);
      document.getElementById('add-loc-name').value = '';
      document.getElementById('add-loc-desc').value = '';
      var submapX = document.getElementById('add-submap-x');
      var submapY = document.getElementById('add-submap-y');
      if (submapX) submapX.value = pct.x.toFixed(2);
      if (submapY) submapY.value = pct.y.toFixed(2);
      document.getElementById('map-add-modal').style.display = 'block';
    });

    // Tab switching
    document.querySelectorAll('.map-add-tab').forEach(function(tab) {
      tab.addEventListener('click', function() {
        document.querySelectorAll('.map-add-tab').forEach(function(t) { t.classList.remove('active'); });
        document.querySelectorAll('.map-add-tab-content').forEach(function(c) { c.style.display = 'none'; });
        tab.classList.add('active');
        document.getElementById('tab-' + tab.getAttribute('data-tab')).style.display = 'block';

        // Load standalone maps when Link Existing tab is clicked
        if (tab.getAttribute('data-tab') === 'linkmap') {
          var sel = document.getElementById('link-map-select');
          if (sel) {
            sel.innerHTML = '<option value="">Loading...</option>';
            fetch('/map/<%= map.id %>/standalone-maps')
              .then(function(r) { return r.json(); })
              .then(function(data) {
                if (!data.maps || data.maps.length === 0) {
                  sel.innerHTML = '<option value="">No standalone maps available</option>';
                  return;
                }
                var html = '<option value="">-- Select a map --</option>';
                data.maps.forEach(function(m) {
                  html += '<option value="' + m.id + '">' + escHtml(m.name) + '</option>';
                });
                sel.innerHTML = html;
              });
          }
        }
      });
    });

    // Link existing map button
    window.unlinkMap = function(linkId) {
      if (!confirm('Remove this map link?')) return;
      fetch('/map/<%= map.id %>/links/' + linkId + '/delete', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'X-CSRF-Token': csrfToken }
      }).then(function(r) { return r.json(); }).then(function(d) {
        if (d.success) location.reload();
        else alert(d.error || 'Failed to unlink');
      });
    };

    var linkBtn = document.getElementById('link-map-btn');
    if (linkBtn) {
      linkBtn.addEventListener('click', function() {
        var sel = document.getElementById('link-map-select');
        var mapId = parseInt(sel.value);
        if (!mapId) { alert('Please select a map'); return; }
        var lx = document.getElementById('add-loc-x').value;
        var ly = document.getElementById('add-loc-y').value;
        fetch('/map/<%= map.id %>/link-existing', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', 'X-CSRF-Token': csrfToken },
          body: JSON.stringify({ map_id: mapId, pin_x: parseFloat(lx), pin_y: parseFloat(ly) })
        }).then(function(r) { return r.json(); }).then(function(d) {
          if (d.success) location.reload();
          else alert(d.error || 'Failed to link map');
        });
      });
    }
  }

  // ---- Fullscreen ----
  var wrapper = document.getElementById('map-wrapper');
  var fsBtn = document.getElementById('map-fullscreen-btn');
  var fsCloseBtn = document.getElementById('map-fullscreen-close');
  var isFullscreen = false;

  function toggleFullscreen() {
    isFullscreen = !isFullscreen;
    if (isFullscreen) {
      wrapper.classList.add('map-fullscreen');
      document.body.classList.add('map-fs-active');
      fsBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="4 14 10 14 10 20"></polyline><polyline points="20 10 14 10 14 4"></polyline><line x1="14" y1="10" x2="21" y2="3"></line><line x1="3" y1="21" x2="10" y2="14"></line></svg> Exit Fullscreen';
    } else {
      wrapper.classList.remove('map-fullscreen');
      document.body.classList.remove('map-fs-active');
      fsBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="15 3 21 3 21 9"></polyline><polyline points="9 21 3 21 3 15"></polyline><line x1="21" y1="3" x2="14" y2="10"></line><line x1="3" y1="21" x2="10" y2="14"></line></svg> Fullscreen';
    }
    setTimeout(function() { leafletMap.invalidateSize(); }, 100);
  }

  fsBtn.addEventListener('click', toggleFullscreen);
  fsCloseBtn.addEventListener('click', function() {
    if (isFullscreen) toggleFullscreen();
  });

  // Fullscreen toolbar button wiring
  var fsTkBtn = document.getElementById('fs-token-btn');
  if (fsTkBtn) fsTkBtn.addEventListener('click', function() {
    document.getElementById('token-picker-btn').click();
  });
  var fsNpcBtn = document.getElementById('fs-npc-btn');
  if (fsNpcBtn) fsNpcBtn.addEventListener('click', function() {
    document.getElementById('npc-picker-btn').click();
  });
  var fsScaleBtn = document.getElementById('fs-scale-btn');
  if (fsScaleBtn) fsScaleBtn.addEventListener('click', function() {
    document.getElementById('token-scale-btn').click();
  });
  var fsFogBtn = document.getElementById('fs-fog-btn');
  if (fsFogBtn) fsFogBtn.addEventListener('click', function() {
    document.getElementById('fog-toggle-btn').click();
  });

  document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape') {
      if (isFullscreen) toggleFullscreen();
      document.getElementById('map-add-modal') && (document.getElementById('map-add-modal').style.display = 'none');
      document.getElementById('token-picker-modal').style.display = 'none';
      if (isDM) {
        var sidebar = document.getElementById('npc-sidebar');
        if (sidebar) sidebar.style.display = 'none';
        // Clear multi-select
        selectedTokens.forEach(function(info) { deselectMarker(info); });
        selectedTokens.clear();
      }
    }
  });

  // ---- Condition Picker ----
  var conditionPickerOverlay = null;

  function openConditionPicker(token, marker) {
    // Close existing
    if (conditionPickerOverlay) conditionPickerOverlay.remove();

    conditionPickerOverlay = document.createElement('div');
    conditionPickerOverlay.className = 'condition-picker-overlay';
    conditionPickerOverlay.innerHTML = '<div class="condition-picker-card card">'
      + '<h3 style="margin-bottom:0.5rem;">Add Condition</h3>'
      + '<input type="text" class="condition-picker-search" placeholder="Search conditions..." style="width:100%;margin-bottom:0.5rem;">'
      + '<div class="condition-picker-list"><p class="text-muted">Loading...</p></div>'
      + '<button type="button" class="btn btn-outline btn-small" style="margin-top:0.5rem;" id="condition-picker-close">Cancel</button>'
      + '</div>';
    document.body.appendChild(conditionPickerOverlay);

    conditionPickerOverlay.querySelector('#condition-picker-close').addEventListener('click', function() {
      conditionPickerOverlay.remove();
      conditionPickerOverlay = null;
    });
    conditionPickerOverlay.addEventListener('click', function(e) {
      if (e.target === conditionPickerOverlay) {
        conditionPickerOverlay.remove();
        conditionPickerOverlay = null;
      }
    });

    fetch('/map/<%= map.id %>/conditions-list')
      .then(function(r) { return r.json(); })
      .then(function(data) {
        var list = conditionPickerOverlay.querySelector('.condition-picker-list');
        var search = conditionPickerOverlay.querySelector('.condition-picker-search');
        var allConds = data.conditions || [];
        var existingNames = (token.conditions || []).map(function(c) { return c.condition_name; });

        function renderList(filter) {
          var html = '';
          allConds.forEach(function(c) {
            var name = c.name;
            if (filter && name.toLowerCase().indexOf(filter.toLowerCase()) === -1) return;
            var already = existingNames.indexOf(name) !== -1;
            var color = getCondColor(name);
            html += '<button type="button" class="condition-picker-item' + (already ? ' disabled' : '') + '" '
              + (already ? 'disabled' : 'data-cond-name="' + escHtml(name) + '"') + '>'
              + '<span class="condition-picker-icon" style="background:' + color + ';">' + getCondIcon(name) + '</span>'
              + '<span>' + escHtml(name) + '</span>'
              + (already ? '<span class="token-picker-placed">Applied</span>' : '')
              + '</button>';
          });
          if (!html) html = '<p class="text-muted">No conditions found.</p>';
          list.innerHTML = html;

          list.querySelectorAll('[data-cond-name]').forEach(function(btn) {
            btn.addEventListener('click', function() {
              var condName = btn.getAttribute('data-cond-name');
              fetch('/map/<%= map.id %>/tokens/' + token.id + '/conditions', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'X-CSRF-Token': csrfToken },
                body: JSON.stringify({ condition_name: condName })
              }).then(function(r) { return r.json(); }).then(function(d) {
                if (d.success) {
                  token.conditions.push({ id: d.conditionId, condition_name: d.condition_name, token_id: token.id });
                  existingNames.push(condName);
                  marker.setIcon(makeTokenIcon(token));
                  renderList(search.value);
                  marker.closePopup(); marker.unbindPopup(); marker.bindPopup(buildTokenPopup(token), { maxWidth: 220 }); marker.openPopup();
                  // Trigger entrance animation on new badges
                  triggerCondEntrance(marker);
                }
              });
            });
          });
        }

        renderList('');
        search.addEventListener('input', function() { renderList(this.value); });
        search.focus();
      });
  }

  // ---- Scale Panel (DM only) ----
  if (isDM) {
    var scaleBtn = document.getElementById('token-scale-btn');
    var scalePanel = document.getElementById('token-scale-panel');
    var scaleOffset = document.getElementById('token-scale-offset');
    var scalePlus = document.getElementById('token-scale-plus');
    var scaleMinus = document.getElementById('token-scale-minus');
    var scaleClose = document.getElementById('token-scale-close');
    var cumulativeOffset = 0;

    scaleBtn.addEventListener('click', function() {
      scalePanel.style.display = scalePanel.style.display === 'none' ? 'block' : 'none';
    });
    scaleClose.addEventListener('click', function() { scalePanel.style.display = 'none'; });

    function applyScaleDelta(delta) {
      fetch('/map/<%= map.id %>/tokens/resize-all', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'X-CSRF-Token': csrfToken },
        body: JSON.stringify({ delta: delta })
      }).then(function(r) { return r.json(); }).then(function(d) {
        if (d.success) {
          cumulativeOffset = Math.round((cumulativeOffset + delta) * 10) / 10;
          scaleOffset.textContent = (cumulativeOffset >= 0 ? '+' : '') + cumulativeOffset.toFixed(1);
          // Update all player token markers
          tokensData.forEach(function(t) {
            t.scale = Math.max(0.3, Math.min(3.0, (t.scale || 1.0) + delta));
            if (tokenMarkers[t.id]) tokenMarkers[t.id].setIcon(makeTokenIcon(t));
          });
          // Update all NPC token markers
          npcTokensData.forEach(function(nt) {
            nt.scale = Math.max(0.3, Math.min(3.0, (nt.scale || 1.0) + delta));
            if (npcMarkers[nt.id]) npcMarkers[nt.id].setIcon(makeNpcTokenIcon(nt));
          });
        }
      });
    }

    scalePlus.addEventListener('click', function() { applyScaleDelta(0.1); });
    scaleMinus.addEventListener('click', function() { applyScaleDelta(-0.1); });
  }

  // ---- Toggle Hidden ----
  var toggleHiddenBtn = document.getElementById('toggle-hidden-btn');
  if (toggleHiddenBtn) {
    toggleHiddenBtn.addEventListener('click', function() {
      fetch('/map/<%= map.id %>/toggle-hidden', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'X-CSRF-Token': csrfToken }
      }).then(function(r) { return r.json(); }).then(function(d) {
        if (d.success) {
          toggleHiddenBtn.textContent = d.hidden ? 'üëÅÔ∏è Unhide' : 'üîí Hide';
          toggleHiddenBtn.title = d.hidden ? 'Unhide Map' : 'Hide Map';
        }
      });
    });
  }

  // ---- Fog of War ----
  var fogEnabled = <%= map.fog_enabled ? 'true' : 'false' %>;
  var fogLayer = null;
  var fogCanvas = null;  // Offscreen mask canvas (small, stores fog data)
  var fogCtx = null;
  var fogMaskW = Math.round(imgW / 5);
  var fogMaskH = Math.round(imgH / 5);
  var fogBrushMode = 'reveal';
  var fogBrushSize = 5;
  var fogDrawing = false;
  var fogDraftSaveTimer = null;

  // Fog pane ‚Äî sits between tiles and markers
  // NPC pane below fog (so fog hides NPCs for players)
  leafletMap.createPane('npcPane');
  leafletMap.getPane('npcPane').style.zIndex = 440;
  leafletMap.createPane('fogPane');
  leafletMap.getPane('fogPane').style.zIndex = 450;
  leafletMap.getPane('fogPane').style.pointerEvents = 'none';

  // Image bounds in Leaflet CRS.Simple coordinates
  var fogBoundsNW = L.latLng(imgH, 0);       // top-left of image
  var fogBoundsSE = L.latLng(0, imgW);        // bottom-right of image

  function createFogCanvas() {
    if (fogCanvas) return;
    fogCanvas = document.createElement('canvas');
    fogCanvas.width = fogMaskW;
    fogCanvas.height = fogMaskH;
    fogCtx = fogCanvas.getContext('2d');
    fogCtx.fillStyle = 'black';
    fogCtx.fillRect(0, 0, fogMaskW, fogMaskH);
  }

  function loadFogFromData(base64) {
    if (!base64) return;
    var img = new Image();
    img.onload = function() {
      fogCtx.clearRect(0, 0, fogMaskW, fogMaskH);
      fogCtx.drawImage(img, 0, 0, fogMaskW, fogMaskH);
      if (fogLayer) fogLayer.redraw();
    };
    img.src = base64;
  }

  function getFogMaskBase64() {
    return fogCanvas.toDataURL('image/png');
  }

  // Custom Leaflet Layer ‚Äî uses a fixed-size canvas + CSS transform (no resize on zoom)
  // The canvas is rendered once at fog mask resolution; zoom/pan only changes CSS transform.
  // This prevents the brief flash that occurs when canvas is resized (which clears it).
  var FOG_RENDER_SCALE = 2; // render at 2x fog mask for crisp edges
  var FogOverlay = L.Layer.extend({
    onAdd: function(map) {
      this._map = map;
      this._el = document.createElement('canvas');
      this._el.className = 'fog-overlay-canvas';
      L.DomUtil.addClass(this._el, 'leaflet-zoom-animated');
      this._el.style.position = 'absolute';
      this._el.style.transformOrigin = '0 0';
      // Fixed canvas size ‚Äî never changes during zoom
      this._el.width = fogMaskW * FOG_RENDER_SCALE;
      this._el.height = fogMaskH * FOG_RENDER_SCALE;
      this._drawFog();
      map.getPane('fogPane').appendChild(this._el);
      map.on('zoomanim', this._onZoomAnim, this);
      map.on('zoomend viewreset moveend', this._updatePosition, this);
      this._updatePosition();
      // Mobile pinch-zoom: update fog position every frame via touchmove
      // zoomanim + CSS transition works for desktop but lags on mobile pinch
      this._pinchActive = false;
      this._onTouchStart = L.Util.bind(function(e) {
        if (e.touches.length >= 2) this._pinchActive = true;
      }, this);
      this._onTouchMove = L.Util.bind(function() {
        if (!this._pinchActive || !this._map._animatingZoom) return;
        // Read current pane transform and apply matching position directly
        var pane = this._map._mapPane;
        var paneTransform = pane.style.transform || pane.style.webkitTransform || '';
        if (paneTransform) {
          // During pinch, Leaflet transforms _mapPane; fog canvas inherits that.
          // We need to update our own transform to match the current zoom target.
          // Use _animateToCenter/_animateToZoom which Leaflet sets during touch zoom.
          var zoom = this._map._animateToZoom;
          var center = this._map._animateToCenter;
          if (zoom !== undefined && center) {
            var topLeft = this._map._latLngToNewLayerPoint(fogBoundsNW, zoom, center);
            var bottomRight = this._map._latLngToNewLayerPoint(fogBoundsSE, zoom, center);
            var scaleX = (bottomRight.x - topLeft.x) / this._el.width;
            // Bypass CSS transition by setting transform directly on the style
            this._el.style.transform = 'translate3d(' + topLeft.x + 'px,' + topLeft.y + 'px,0) scale(' + scaleX + ')';
          }
        }
      }, this);
      this._onTouchEnd = L.Util.bind(function(e) {
        if (e.touches.length < 2) this._pinchActive = false;
      }, this);
      map.getContainer().addEventListener('touchstart', this._onTouchStart, { passive: true });
      map.getContainer().addEventListener('touchmove', this._onTouchMove, { passive: true });
      document.addEventListener('touchend', this._onTouchEnd);
    },
    onRemove: function(map) {
      if (this._el && this._el.parentNode) this._el.parentNode.removeChild(this._el);
      map.off('zoomanim', this._onZoomAnim, this);
      map.off('zoomend viewreset moveend', this._updatePosition, this);
      map.getContainer().removeEventListener('touchstart', this._onTouchStart);
      map.getContainer().removeEventListener('touchmove', this._onTouchMove);
      document.removeEventListener('touchend', this._onTouchEnd);
    },
    // During zoom animation ‚Äî CSS transform only (desktop scroll wheel)
    _onZoomAnim: function(ev) {
      var topLeft = this._map._latLngToNewLayerPoint(fogBoundsNW, ev.zoom, ev.center);
      var bottomRight = this._map._latLngToNewLayerPoint(fogBoundsSE, ev.zoom, ev.center);
      var scaleX = (bottomRight.x - topLeft.x) / this._el.width;
      var scaleY = (bottomRight.y - topLeft.y) / this._el.height;
      L.DomUtil.setTransform(this._el, topLeft, scaleX);
    },
    // After zoom/pan ‚Äî update CSS transform to match current view
    _updatePosition: function() {
      if (!this._map) return;
      var topLeft = this._map.latLngToLayerPoint(fogBoundsNW);
      var bottomRight = this._map.latLngToLayerPoint(fogBoundsSE);
      var scaleX = (bottomRight.x - topLeft.x) / this._el.width;
      var scaleY = (bottomRight.y - topLeft.y) / this._el.height;
      L.DomUtil.setTransform(this._el, topLeft, scaleX);
    },
    // Redraw fog onto the fixed-size canvas (called only when fog data changes)
    _drawFog: function() {
      if (!fogCanvas) return;
      var w = this._el.width, h = this._el.height;
      var ctx = this._el.getContext('2d');
      ctx.clearRect(0, 0, w, h);
      ctx.globalAlpha = isDM ? 0.5 : 1.0;
      ctx.imageSmoothingEnabled = true;
      ctx.drawImage(fogCanvas, 0, 0, fogMaskW, fogMaskH, 0, 0, w, h);
    },
    // Public: call when fog mask data has changed
    redraw: function() {
      this._drawFog();
    }
  });

  function enableFog() {
    createFogCanvas();
    if (!fogLayer) {
      fogLayer = new FogOverlay();
      fogLayer.addTo(leafletMap);
    }
    fetch('/map/<%= map.id %>/fog').then(function(r) { return r.json(); }).then(function(data) {
      if (isDM && data.fog_draft) {
        loadFogFromData(data.fog_draft);
      } else if (data.fog_data) {
        loadFogFromData(data.fog_data);
      } else {
        // No data yet ‚Äî full fog
        if (fogLayer) fogLayer.redraw();
      }
    });
  }

  function disableFog() {
    if (fogLayer) {
      leafletMap.removeLayer(fogLayer);
      fogLayer = null;
    }
  }

  if (fogEnabled) enableFog();

  // DM Fog Toolbar
  if (isDM) {
    var fogToggleBtn = document.getElementById('fog-toggle-btn');
    var fogToolbar = document.getElementById('fog-toolbar');
    var fogEnableBtn = document.getElementById('fog-enable-btn');
    var fogControls = document.getElementById('fog-controls');
    var fogPublishBtn = document.getElementById('fog-publish-btn');
    var fogResetBtn = document.getElementById('fog-reset-btn');
    var fogBrushSizeSlider = document.getElementById('fog-brush-size');
    var fogBrushSizeVal = document.getElementById('fog-brush-size-val');

    fogToggleBtn.addEventListener('click', function() {
      fogToolbar.style.display = fogToolbar.style.display === 'none' ? 'block' : 'none';
    });
    document.getElementById('fog-toolbar-close').addEventListener('click', function() {
      fogToolbar.style.display = 'none';
    });

    fogEnableBtn.addEventListener('click', function() {
      fetch('/map/<%= map.id %>/fog/toggle', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'X-CSRF-Token': csrfToken }
      }).then(function(r) { return r.json(); }).then(function(d) {
        if (d.success) {
          fogEnabled = !!d.fog_enabled;
          fogEnableBtn.textContent = fogEnabled ? 'Disable FoW' : 'Enable FoW';
          fogControls.style.display = fogEnabled ? 'block' : 'none';
          if (fogEnabled) enableFog();
          else disableFog();
        }
      });
    });

    // Brush mode toggles
    document.querySelectorAll('.fog-brush-btn').forEach(function(btn) {
      btn.addEventListener('click', function() {
        document.querySelectorAll('.fog-brush-btn').forEach(function(b) { b.classList.remove('active'); b.classList.add('btn-outline'); b.classList.remove('btn-primary'); });
        btn.classList.add('active', 'btn-primary');
        btn.classList.remove('btn-outline');
        fogBrushMode = btn.getAttribute('data-brush');
      });
    });

    fogBrushSizeSlider.addEventListener('input', function() {
      fogBrushSize = parseInt(this.value);
      fogBrushSizeVal.textContent = fogBrushSize;
      updateBrushCursorSize();
    });

    // Fog brush cursor overlay
    var fogBrushCursor = document.createElement('div');
    fogBrushCursor.id = 'fog-brush-cursor';
    fogBrushCursor.style.cssText = 'position:absolute;border-radius:50%;pointer-events:none;z-index:1001;display:none;transform:translate(-50%,-50%);';
    document.getElementById('map-wrapper').appendChild(fogBrushCursor);

    function updateBrushCursorSize() {
      // Convert brush size (% of image) to screen pixels
      var mapContainerEl = document.getElementById('map-container');
      var nw = leafletMap.latLngToContainerPoint([imgH, 0]);
      var se = leafletMap.latLngToContainerPoint([0, imgW]);
      var screenW = se.x - nw.x;
      var screenH = se.y - nw.y;
      var radiusPx = (fogBrushSize / 100) * Math.max(screenW, screenH);
      var diam = Math.round(radiusPx * 2);
      fogBrushCursor.style.width = diam + 'px';
      fogBrushCursor.style.height = diam + 'px';
    }

    function updateBrushCursorColor() {
      fogBrushCursor.style.background = fogBrushMode === 'reveal' ? 'rgba(46,204,113,0.25)' : 'rgba(231,76,60,0.25)';
      fogBrushCursor.style.border = '2px solid ' + (fogBrushMode === 'reveal' ? 'rgba(46,204,113,0.6)' : 'rgba(231,76,60,0.6)');
    }

    function showBrushCursor() {
      if (!fogEnabled || fogToolbar.style.display === 'none') return false;
      return true;
    }

    leafletMap.on('zoomend', function() { updateBrushCursorSize(); });

    // Brush drawing on map
    var mapContainer = document.getElementById('map-container');
    function fogBrushAt(e) {
      if (!fogEnabled || !fogCanvas) return;
      // Use Leaflet's containerPointToLatLng for accurate coordinate conversion
      var containerRect = mapContainer.getBoundingClientRect();
      var mx = e.clientX - containerRect.left;
      var my = e.clientY - containerRect.top;
      var latlng = leafletMap.containerPointToLatLng([mx, my]);

      // Convert latlng to 0-1 fraction of image
      var fracX = latlng.lng / imgW;
      var fracY = 1 - (latlng.lat / imgH);
      if (fracX < 0 || fracX > 1 || fracY < 0 || fracY > 1) return;

      // Map to fog mask pixel coordinates
      var cx = fracX * fogMaskW;
      var cy = fracY * fogMaskH;
      var radius = (fogBrushSize / 100) * Math.max(fogMaskW, fogMaskH);

      if (fogBrushMode === 'reveal') {
        fogCtx.globalCompositeOperation = 'destination-out';
      } else {
        fogCtx.globalCompositeOperation = 'source-over';
        fogCtx.fillStyle = 'black';
      }
      fogCtx.beginPath();
      fogCtx.arc(cx, cy, radius, 0, Math.PI * 2);
      fogCtx.fill();
      fogCtx.globalCompositeOperation = 'source-over';

      if (fogLayer) fogLayer.redraw();

      // Debounced save
      clearTimeout(fogDraftSaveTimer);
      fogDraftSaveTimer = setTimeout(function() {
        fetch('/map/<%= map.id %>/fog/draft', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', 'X-CSRF-Token': csrfToken },
          body: JSON.stringify({ fog_draft: getFogMaskBase64() })
        });
      }, 2000);
    }

    mapContainer.addEventListener('mousedown', function(e) {
      if (!fogEnabled || e.button !== 0) return;
      if (fogToolbar.style.display === 'none') return;
      fogDrawing = true;
      leafletMap.dragging.disable();
      fogBrushAt(e);
    });
    mapContainer.addEventListener('mousemove', function(e) {
      if (fogDrawing) fogBrushAt(e);
      // Show brush cursor while fog toolbar is visible
      if (showBrushCursor()) {
        var wrapperRect = document.getElementById('map-wrapper').getBoundingClientRect();
        fogBrushCursor.style.display = 'block';
        fogBrushCursor.style.left = (e.clientX - wrapperRect.left) + 'px';
        fogBrushCursor.style.top = (e.clientY - wrapperRect.top) + 'px';
        updateBrushCursorColor();
        updateBrushCursorSize();
      } else {
        fogBrushCursor.style.display = 'none';
      }
    });
    mapContainer.addEventListener('mouseleave', function() {
      fogBrushCursor.style.display = 'none';
    });
    document.addEventListener('mouseup', function() {
      if (fogDrawing) {
        fogDrawing = false;
        leafletMap.dragging.enable();
      }
    });

    // Touch events for FoW drawing on mobile/tablet
    mapContainer.addEventListener('touchstart', function(e) {
      if (!fogEnabled || fogToolbar.style.display === 'none') return;
      if (!showBrushCursor()) return;
      e.preventDefault();
      fogDrawing = true;
      leafletMap.dragging.disable();
      var touch = e.touches[0];
      fogBrushAt({ clientX: touch.clientX, clientY: touch.clientY });
    }, { passive: false });
    mapContainer.addEventListener('touchmove', function(e) {
      if (!fogDrawing) return;
      e.preventDefault();
      var touch = e.touches[0];
      fogBrushAt({ clientX: touch.clientX, clientY: touch.clientY });
    }, { passive: false });
    document.addEventListener('touchend', function() {
      if (fogDrawing) {
        fogDrawing = false;
        leafletMap.dragging.enable();
      }
    });

    fogPublishBtn.addEventListener('click', function() {
      fetch('/map/<%= map.id %>/fog/draft', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'X-CSRF-Token': csrfToken },
        body: JSON.stringify({ fog_draft: getFogMaskBase64() })
      }).then(function() {
        return fetch('/map/<%= map.id %>/fog/publish', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', 'X-CSRF-Token': csrfToken }
        });
      }).then(function(r) { return r.json(); }).then(function(d) {
        if (d.success) {
          fogPublishBtn.textContent = 'Published!';
          setTimeout(function() { fogPublishBtn.textContent = 'Publish'; }, 2000);
        }
      });
    });

    fogResetBtn.addEventListener('click', function() {
      if (!confirm('Discard draft changes and revert to published fog?')) return;
      fetch('/map/<%= map.id %>/fog/reset-draft', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'X-CSRF-Token': csrfToken }
      }).then(function(r) { return r.json(); }).then(function(d) {
        if (d.success) {
          fetch('/map/<%= map.id %>/fog').then(function(r) { return r.json(); }).then(function(data) {
            if (data.fog_draft) loadFogFromData(data.fog_draft);
            else {
              fogCtx.fillStyle = 'black';
              fogCtx.fillRect(0, 0, fogMaskW, fogMaskH);
              if (fogLayer) fogLayer.redraw();
            }
          });
        }
      });
    });
  }

  // SSE fog updates ‚Äî always listen, handle even if fog was enabled after page load
  if (typeof EventSource !== 'undefined') {
    try {
      var fogSSE = new EventSource('/api/events');
      fogSSE.addEventListener('fog-update', function(e) {
        try {
          var data = JSON.parse(e.data);
          if (data.mapId !== mapData.id) return;
          // Always fetch latest fog state ‚Äî handles fog being enabled/disabled dynamically
          fetch('/map/<%= map.id %>/fog').then(function(r) { return r.json(); }).then(function(d) {
            fogEnabled = !!d.fog_enabled;
            if (fogEnabled && d.fog_data) {
              createFogCanvas();
              loadFogFromData(d.fog_data);
              if (!fogLayer) {
                fogLayer = new FogOverlay();
                fogLayer.addTo(leafletMap);
              }
            } else if (!fogEnabled) {
              disableFog();
            }
          });
        } catch(err) {}
      });
    } catch(e) {}
  }

  // ---- NPC Tokens on Map ----
  var npcMarkers = {};

  function makeNpcTokenIcon(nt) {
    var scale = nt.scale || 1.0;
    var avatarSize = Math.round(28 * scale);
    var alignment = nt.alignment || 'hostile';
    var alignColors = { hostile: '#e74c3c', friendly: '#2ecc71', neutral: '#ecf0f1' };
    var alignColor = alignColors[alignment] || alignColors.hostile;
    var avatarHtml;
    if (nt.npc_avatar) {
      avatarHtml = '<img src="' + escHtml(nt.npc_avatar) + '" alt="" class="map-token-avatar map-npc-token-avatar" style="width:' + avatarSize + 'px;height:' + avatarSize + 'px;border-color:' + alignColor + ' !important;box-shadow:0 0 6px ' + alignColor + '80 !important;">';
    } else {
      avatarHtml = '<div class="map-token-avatar map-token-no-avatar map-npc-token-avatar" style="width:' + avatarSize + 'px;height:' + avatarSize + 'px;font-size:' + (0.75 * scale) + 'rem;border-color:' + alignColor + ' !important;box-shadow:0 0 6px ' + alignColor + '80 !important;">' + escHtml(nt.npc_name.charAt(0).toUpperCase()) + '</div>';
    }

    // HP bar
    var hpHtml = '';
    if (nt.max_hp > 0 && (isDM || nt.hp_visible)) {
      var hp = nt.current_hp || 0;
      var pct = Math.min(100, Math.max(0, (hp / nt.max_hp) * 100));
      var hpColor = pct > 50 ? '#27ae60' : pct > 25 ? '#f39c12' : '#e74c3c';
      hpHtml = '<div class="npc-hp-bar" style="width:' + avatarSize + 'px;"><div class="npc-hp-fill" style="width:' + pct + '%;background:' + hpColor + ';"></div></div>';
    }

    // Condition badges
    var condHtml = '';
    var conditions = nt.conditions || [];
    if (conditions.length > 0) {
      condHtml = '<div class="token-conditions">';
      for (var i = 0; i < Math.min(conditions.length, 4); i++) {
        var c = conditions[i];
        var color = getCondColor(c.condition_name);
        condHtml += '<div class="token-condition-badge" style="background:' + color + ';" title="' + escHtml(c.condition_name) + '">' + getCondIcon(c.condition_name) + '</div>';
      }
      if (conditions.length > 4) condHtml += '<div class="token-condition-badge token-condition-overflow">+' + (conditions.length - 4) + '</div>';
      condHtml += '</div>';
    }

    // Hidden badge
    var hiddenBadge = '';
    if (nt.hidden && isDM) {
      hiddenBadge = '<div class="npc-hidden-badge" title="Hidden from players">üëÅÔ∏è‚Äçüó®Ô∏è</div>';
    }

    var labelHtml = '<div class="map-token-label npc-token-label">' + escHtml(nt.npc_name) + '</div>';
    var iconW = Math.max(40, avatarSize + 12);
    var iconH = Math.round(avatarSize + 30);

    return L.divIcon({
      className: 'map-token' + (nt.hidden ? ' npc-hidden' : ''),
      html: '<div class="map-token-wrapper">' + hiddenBadge + avatarHtml + condHtml + hpHtml + labelHtml + '</div>',
      iconSize: [iconW, iconH],
      iconAnchor: [iconW / 2, iconH / 2]
    });
  }

  function buildNpcPopup(nt) {
    var html = '<div style="text-align:center;">'
      + '<strong style="color:#e74c3c;">' + escHtml(nt.npc_name) + '</strong>';

    if (nt.max_hp > 0 && (isDM || nt.hp_visible)) {
      html += '<br><span id="npc-hp-label-' + nt.id + '" class="text-muted" style="font-size:0.8rem;">HP: ' + (nt.current_hp || 0) + ' / ' + nt.max_hp + '</span>';
    }

    if (isDM) {
      // HP calculator
      if (nt.max_hp > 0) {
        html += '<div style="margin-top:0.4rem;"><input type="text" id="npc-hp-calc-' + nt.id + '" placeholder="+15 or -33" style="width:80px;padding:0.2rem 0.4rem;font-size:0.8rem;background:var(--bg-input);border:1px solid var(--border);border-radius:4px;color:var(--text-primary);text-align:center;">'
          + ' <button type="button" class="btn btn-small btn-primary" data-npc-hp-apply="' + nt.id + '" style="font-size:0.7rem;padding:0.15rem 0.4rem;">Apply</button></div>';
      }

      // Alignment selector
      var curAlign = nt.alignment || 'hostile';
      html += '<div style="margin-top:0.4rem;"><select data-npc-alignment="' + nt.id + '" style="font-size:0.7rem;padding:0.15rem 0.3rem;background:var(--bg-input);border:1px solid var(--border);border-radius:4px;color:var(--text-primary);">'
        + '<option value="hostile"' + (curAlign === 'hostile' ? ' selected' : '') + '>üî¥ Hostile</option>'
        + '<option value="friendly"' + (curAlign === 'friendly' ? ' selected' : '') + '>üü¢ Friendly</option>'
        + '<option value="neutral"' + (curAlign === 'neutral' ? ' selected' : '') + '>‚ö™ Neutral</option>'
        + '</select></div>';

      // Toggle buttons
      html += '<div style="margin-top:0.4rem;display:flex;gap:0.25rem;justify-content:center;flex-wrap:wrap;">';
      if (nt.max_hp > 0) {
        html += '<button type="button" class="btn btn-small btn-outline" id="npc-toggle-hp-btn-' + nt.id + '" data-npc-toggle-hp="' + nt.id + '" style="font-size:0.65rem;padding:0.1rem 0.3rem;">' + (nt.hp_visible ? 'üîí Hide HP' : 'üëÅÔ∏è Show HP') + '</button>';
      }
      html += '<button type="button" class="btn btn-small btn-outline" id="npc-toggle-hidden-btn-' + nt.id + '" data-npc-toggle-hidden="' + nt.id + '" style="font-size:0.65rem;padding:0.1rem 0.3rem;">' + (nt.hidden ? 'üëÅÔ∏è Reveal' : 'üôà Hide') + '</button>';
      html += '<button type="button" class="btn btn-small btn-outline" data-npc-add-condition="' + nt.id + '" style="font-size:0.65rem;padding:0.1rem 0.3rem;">+ Cond</button>';
      html += '</div>';

      // Conditions list
      var conds = nt.conditions || [];
      if (conds.length > 0) {
        html += '<div style="display:flex;flex-wrap:wrap;gap:3px;justify-content:center;margin-top:0.3rem;">';
        conds.forEach(function(c) {
          html += '<span class="token-popup-cond-badge" style="background:' + getCondColor(c.condition_name) + ';">' + getCondIcon(c.condition_name) + ' ' + escHtml(c.condition_name)
            + ' <span class="token-popup-cond-remove" data-npc-remove-cond="' + c.id + '" data-npc-token-id="' + nt.id + '">&times;</span></span>';
        });
        html += '</div>';
      }

      // Resize
      html += '<div style="margin-top:0.4rem;"><label style="font-size:0.7rem;color:var(--text-secondary);">Size: <span id="npc-resize-val-' + nt.id + '">' + (nt.scale || 1.0).toFixed(1) + 'x</span></label>'
        + '<input type="range" min="0.5" max="3.0" step="0.1" value="' + (nt.scale || 1.0) + '" data-npc-resize="' + nt.id + '" style="width:100%;margin:0.2rem 0;"></div>';

      // Remove
      html += '<button type="button" class="btn btn-small btn-danger" data-npc-remove="' + nt.id + '" style="font-size:0.75rem;margin-top:0.3rem;">Remove</button>';
    } else {
      // Player view: just show conditions
      var conds = nt.conditions || [];
      if (conds.length > 0) {
        html += '<div style="display:flex;flex-wrap:wrap;gap:3px;justify-content:center;margin-top:0.3rem;">';
        conds.forEach(function(c) {
          html += '<span class="token-popup-cond-badge" style="background:' + getCondColor(c.condition_name) + ';">' + getCondIcon(c.condition_name) + ' ' + escHtml(c.condition_name) + '</span>';
        });
        html += '</div>';
      }
    }

    html += '</div>';
    return html;
  }

  function bindNpcPopup(marker, nt) {
    marker.unbindPopup();
    marker.bindPopup(buildNpcPopup(nt), { maxWidth: 280 });

    marker.off('popupopen').on('popupopen', function() {
      setupNpcPopupHandlers(marker, nt);
    });
  }

  function setupNpcPopupHandlers(marker, nt) {
      // Alignment selector
      var alignSelect = document.querySelector('[data-npc-alignment="' + nt.id + '"]');
      if (alignSelect) {
        alignSelect.addEventListener('change', function() {
          var val = this.value;
          fetch('/map/<%= map.id %>/npc-tokens/' + nt.id + '/alignment', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'X-CSRF-Token': csrfToken },
            body: JSON.stringify({ alignment: val })
          }).then(function(r) { return r.json(); }).then(function(d) {
            if (d.success) {
              nt.alignment = d.alignment;
              marker.setIcon(makeNpcTokenIcon(nt));
            }
          });
        });
      }
      // HP Apply
      var hpBtn = document.querySelector('[data-npc-hp-apply="' + nt.id + '"]');
      if (hpBtn) {
        hpBtn.addEventListener('click', function() {
          var input = document.getElementById('npc-hp-calc-' + nt.id);
          var val = (input.value || '').trim();
          var delta = 0;
          if (val.startsWith('+')) delta = parseInt(val.substring(1)) || 0;
          else if (val.startsWith('-')) delta = -(parseInt(val.substring(1)) || 0);
          else delta = parseInt(val) || 0;
          if (delta === 0) return;
          fetch('/map/<%= map.id %>/npc-tokens/' + nt.id + '/hp', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'X-CSRF-Token': csrfToken },
            body: JSON.stringify({ delta: delta })
          }).then(function(r) { return r.json(); }).then(function(d) {
            if (d.success) {
              nt.current_hp = d.current_hp;
              marker.setIcon(makeNpcTokenIcon(nt));
              // Update HP text in-place without rebuilding popup
              var hpLabel = document.getElementById('npc-hp-label-' + nt.id);
              if (hpLabel) hpLabel.textContent = 'HP: ' + d.current_hp + ' / ' + (d.max_hp || nt.max_hp);
              input.value = '';
            }
          });
        });
      }

      // HP Apply on Enter key
      var hpInput = document.getElementById('npc-hp-calc-' + nt.id);
      if (hpInput) {
        hpInput.addEventListener('keydown', function(e) {
          if (e.key === 'Enter') {
            e.preventDefault();
            var applyBtn = document.querySelector('[data-npc-hp-apply="' + nt.id + '"]');
            if (applyBtn) applyBtn.click();
          }
        });
      }

      // Toggle HP visible
      var toggleHpBtn = document.querySelector('[data-npc-toggle-hp="' + nt.id + '"]');
      if (toggleHpBtn) {
        toggleHpBtn.addEventListener('click', function() {
          fetch('/map/<%= map.id %>/npc-tokens/' + nt.id + '/toggle-hp-visible', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'X-CSRF-Token': csrfToken }
          }).then(function(r) { return r.json(); }).then(function(d) {
            if (d.success) {
              nt.hp_visible = d.hp_visible;
              marker.setIcon(makeNpcTokenIcon(nt));
              // Update button text in-place (DM always sees HP, this only toggles player visibility)
              var btn = document.getElementById('npc-toggle-hp-btn-' + nt.id);
              if (btn) btn.innerHTML = d.hp_visible ? 'üîí Hide HP' : 'üëÅÔ∏è Show HP';
            }
          });
        });
      }

      // Toggle hidden
      var toggleHiddenBtn = document.querySelector('[data-npc-toggle-hidden="' + nt.id + '"]');
      if (toggleHiddenBtn) {
        toggleHiddenBtn.addEventListener('click', function() {
          fetch('/map/<%= map.id %>/npc-tokens/' + nt.id + '/toggle-hidden', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'X-CSRF-Token': csrfToken }
          }).then(function(r) { return r.json(); }).then(function(d) {
            if (d.success) {
              nt.hidden = d.hidden;
              marker.setIcon(makeNpcTokenIcon(nt));
              // Update button text in-place
              var btn = document.getElementById('npc-toggle-hidden-btn-' + nt.id);
              if (btn) btn.innerHTML = d.hidden ? 'üëÅÔ∏è Reveal' : 'üôà Hide';
            }
          });
        });
      }

      // Add condition
      var addCondBtn = document.querySelector('[data-npc-add-condition="' + nt.id + '"]');
      if (addCondBtn) {
        addCondBtn.addEventListener('click', function() {
          openNpcConditionPicker(nt, marker);
        });
      }

      // Remove conditions
      document.querySelectorAll('[data-npc-remove-cond]').forEach(function(btn) {
        if (parseInt(btn.getAttribute('data-npc-token-id')) === nt.id) {
          btn.addEventListener('click', function(e) {
            e.stopPropagation();
            var condId = btn.getAttribute('data-npc-remove-cond');
            fetch('/map/<%= map.id %>/npc-tokens/' + nt.id + '/conditions/' + condId + '/delete', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json', 'X-CSRF-Token': csrfToken }
            }).then(function(r) { return r.json(); }).then(function(d) {
              if (d.success) {
                nt.conditions = nt.conditions.filter(function(c) { return c.id !== parseInt(condId); });
                marker.setIcon(makeNpcTokenIcon(nt));
                // Remove the badge from DOM in-place
                var badge = btn.closest('.token-popup-cond-badge');
                if (badge) badge.remove();
              }
            });
          });
        }
      });

      // Resize
      var resizeSlider = document.querySelector('[data-npc-resize="' + nt.id + '"]');
      if (resizeSlider) {
        resizeSlider.addEventListener('input', function() {
          document.getElementById('npc-resize-val-' + nt.id).textContent = parseFloat(this.value).toFixed(1) + 'x';
        });
        resizeSlider.addEventListener('change', function() {
          var val = parseFloat(this.value);
          nt.scale = val;
          marker.setIcon(makeNpcTokenIcon(nt));
          fetch('/map/<%= map.id %>/npc-tokens/' + nt.id + '/resize', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'X-CSRF-Token': csrfToken },
            body: JSON.stringify({ scale: val })
          });
        });
      }

      // Remove from map
      var removeBtn = document.querySelector('[data-npc-remove="' + nt.id + '"]');
      if (removeBtn) {
        removeBtn.addEventListener('click', function() {
          fetch('/map/<%= map.id %>/npc-tokens/' + nt.id + '/delete', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'X-CSRF-Token': csrfToken }
          }).then(function(r) { return r.json(); }).then(function(d) {
            if (d.success) {
              leafletMap.removeLayer(marker);
              delete npcMarkers[nt.id];
            }
          });
        });
      }
  }

  function openNpcConditionPicker(nt, marker) {
    if (conditionPickerOverlay) conditionPickerOverlay.remove();
    conditionPickerOverlay = document.createElement('div');
    conditionPickerOverlay.className = 'condition-picker-overlay';
    conditionPickerOverlay.innerHTML = '<div class="condition-picker-card card">'
      + '<h3 style="margin-bottom:0.5rem;">Add Condition</h3>'
      + '<input type="text" class="condition-picker-search" placeholder="Search..." style="width:100%;margin-bottom:0.5rem;">'
      + '<div class="condition-picker-list"><p class="text-muted">Loading...</p></div>'
      + '<button type="button" class="btn btn-outline btn-small" style="margin-top:0.5rem;" id="condition-picker-close">Cancel</button></div>';
    document.body.appendChild(conditionPickerOverlay);
    conditionPickerOverlay.querySelector('#condition-picker-close').addEventListener('click', function() { conditionPickerOverlay.remove(); conditionPickerOverlay = null; });
    conditionPickerOverlay.addEventListener('click', function(e) { if (e.target === conditionPickerOverlay) { conditionPickerOverlay.remove(); conditionPickerOverlay = null; } });

    fetch('/map/<%= map.id %>/conditions-list').then(function(r) { return r.json(); }).then(function(data) {
      var list = conditionPickerOverlay.querySelector('.condition-picker-list');
      var search = conditionPickerOverlay.querySelector('.condition-picker-search');
      var allConds = data.conditions || [];
      var existingNames = (nt.conditions || []).map(function(c) { return c.condition_name; });
      function renderList(filter) {
        var html = '';
        allConds.forEach(function(c) {
          var name = c.name;
          if (filter && name.toLowerCase().indexOf(filter.toLowerCase()) === -1) return;
          var already = existingNames.indexOf(name) !== -1;
          html += '<button type="button" class="condition-picker-item' + (already ? ' disabled' : '') + '" '
            + (already ? 'disabled' : 'data-cond-name="' + escHtml(name) + '"') + '>'
            + '<span class="condition-picker-icon" style="background:' + getCondColor(name) + ';">' + getCondIcon(name) + '</span>'
            + '<span>' + escHtml(name) + '</span>'
            + (already ? '<span class="token-picker-placed">Applied</span>' : '') + '</button>';
        });
        if (!html) html = '<p class="text-muted">No conditions found.</p>';
        list.innerHTML = html;
        list.querySelectorAll('[data-cond-name]').forEach(function(btn) {
          btn.addEventListener('click', function() {
            var condName = btn.getAttribute('data-cond-name');
            fetch('/map/<%= map.id %>/npc-tokens/' + nt.id + '/conditions', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json', 'X-CSRF-Token': csrfToken },
              body: JSON.stringify({ condition_name: condName })
            }).then(function(r) { return r.json(); }).then(function(d) {
              if (d.success) {
                nt.conditions.push({ id: d.conditionId, condition_name: d.condition_name, npc_map_token_id: nt.id });
                existingNames.push(condName);
                marker.setIcon(makeNpcTokenIcon(nt));
                renderList(search.value);
                // Rebuild popup to show new condition badge (popup is behind overlay)
                bindNpcPopup(marker, nt);
              }
            });
          });
        });
      }
      renderList('');
      search.addEventListener('input', function() { renderList(this.value); });
      search.focus();
    });
  }

  // Render existing NPC tokens
  npcTokensData.forEach(function(nt) {
    // Players don't see hidden NPCs
    if (nt.hidden && !isDM) return;
    var ll = pctToLatLng(nt.x, nt.y);
    var npcMarkerOpts = { icon: makeNpcTokenIcon(nt), draggable: isDM };
    if (!isDM) npcMarkerOpts.pane = 'npcPane';
    var marker = L.marker(ll, npcMarkerOpts).addTo(leafletMap);
    npcMarkers[nt.id] = marker;
    bindNpcPopup(marker, nt);
    if (isDM) {
      marker.on('dragend', function() {
        var pct = latLngToPct(marker.getLatLng());
        fetch('/map/<%= map.id %>/npc-tokens/' + nt.id + '/move', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', 'X-CSRF-Token': csrfToken },
          body: JSON.stringify({ x: pct.x, y: pct.y })
        });
      });
    }
  });

  // ---- NPC Sidebar & Library (DM only) ----
  if (isDM) {
    var npcPickerBtn = document.getElementById('npc-picker-btn');
    var npcSidebar = document.getElementById('npc-sidebar');
    var npcSidebarSearch = document.getElementById('npc-sidebar-search');
    var npcSidebarList = document.getElementById('npc-sidebar-list');
    var npcSidebarClose = document.getElementById('npc-sidebar-close');
    var npcSidebarManage = document.getElementById('npc-sidebar-manage');

    function placeNpcOnMap(npcId, npcName, npcAvatar, npcMaxHp, dropX, dropY) {
      fetch('/map/<%= map.id %>/npc-tokens', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'X-CSRF-Token': csrfToken },
        body: JSON.stringify({ npc_token_id: npcId, x: dropX, y: dropY })
      }).then(function(r) { return r.json(); }).then(function(d) {
        if (d.success) {
          var newNt = {
            id: d.id, npc_name: npcName, npc_avatar: npcAvatar,
            max_hp: npcMaxHp, current_hp: npcMaxHp,
            hp_visible: 1, hidden: 0, scale: 1.0, alignment: 'hostile',
            x: dropX, y: dropY, conditions: []
          };
          npcTokensData.push(newNt);
          var ll = pctToLatLng(dropX, dropY);
          var marker = L.marker(ll, { icon: makeNpcTokenIcon(newNt), draggable: true }).addTo(leafletMap);
          npcMarkers[newNt.id] = marker;
          bindNpcPopup(marker, newNt);
          marker.on('dragend', function() {
            var p = latLngToPct(marker.getLatLng());
            fetch('/map/<%= map.id %>/npc-tokens/' + newNt.id + '/move', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json', 'X-CSRF-Token': csrfToken },
              body: JSON.stringify({ x: p.x, y: p.y })
            });
          });
          if (typeof addMultiSelectToMarker === 'function') addMultiSelectToMarker(marker, 'npc', newNt.id, newNt);
        } else {
          alert(d.error || 'Failed');
        }
      });
    }

    function loadNpcSidebar() {
      npcSidebarList.innerHTML = '<p class="text-muted" style="font-size:0.75rem;padding:0.5rem;">Loading...</p>';
      fetch('/map/npcs').then(function(r) { return r.json(); }).then(function(data) {
        var npcs = data.npcs || [];
        var cats = data.categories || [];
        if (npcs.length === 0) {
          npcSidebarList.innerHTML = '<p class="text-muted" style="font-size:0.75rem;padding:0.5rem;">No NPCs. Use Manage Library.</p>';
          return;
        }
        function renderSidebar(filter) {
          var html = '';
          // Group by multi-category ‚Äî NPC appears in each category it belongs to
          var byCat = { '': [] };
          cats.forEach(function(c) { byCat[c.id] = []; });
          npcs.forEach(function(n) {
            if (filter && n.name.toLowerCase().indexOf(filter.toLowerCase()) === -1) return;
            var catIds = n.category_ids || (n.category_id ? [n.category_id] : []);
            if (catIds.length === 0) {
              byCat[''].push(n);
            } else {
              catIds.forEach(function(cid) {
                if (!byCat[cid]) byCat[cid] = [];
                byCat[cid].push(n);
              });
            }
          });
          var catNames = {};
          cats.forEach(function(c) { catNames[c.id] = c.name; });
          var order = [''].concat(cats.map(function(c) { return c.id; }));
          order.forEach(function(catKey) {
            var group = byCat[catKey];
            if (!group || group.length === 0) return;
            var catLabel = catKey ? catNames[catKey] : 'Uncategorized';
            html += '<div class="npc-sidebar-cat" data-cat-key="' + catKey + '">';
            html += '<div class="npc-sidebar-cat-header" data-toggle-cat="' + catKey + '">' + escHtml(catLabel) + ' <span style="font-size:0.65rem;color:var(--text-secondary);">(' + group.length + ')</span></div>';
            html += '<div class="npc-sidebar-cat-items">';
            group.forEach(function(n) {
              var avatarHtml = n.avatar
                ? '<img src="' + escHtml(n.avatar) + '" alt="" style="width:28px;height:28px;border-radius:50%;object-fit:cover;border:2px solid #c0392b;">'
                : '<div style="width:28px;height:28px;border-radius:50%;background:var(--bg-darker);border:2px solid #c0392b;display:flex;align-items:center;justify-content:center;color:#e74c3c;font-size:0.65rem;font-weight:700;">' + escHtml(n.name.charAt(0).toUpperCase()) + '</div>';
              html += '<div class="npc-sidebar-item" draggable="true" data-npc-id="' + n.id + '" data-npc-name="' + escHtml(n.name) + '" data-npc-avatar="' + escHtml(n.avatar || '') + '" data-npc-max-hp="' + (n.max_hp || 0) + '">'
                + avatarHtml
                + '<span class="npc-sidebar-name">' + escHtml(n.name) + '</span>'
                + '</div>';
            });
            html += '</div></div>';
          });
          if (!html) html = '<p class="text-muted" style="font-size:0.75rem;padding:0.5rem;">No NPCs match search.</p>';
          npcSidebarList.innerHTML = html;

          // Category accordion toggle
          npcSidebarList.querySelectorAll('[data-toggle-cat]').forEach(function(hdr) {
            hdr.addEventListener('click', function() {
              var items = hdr.nextElementSibling;
              items.style.display = items.style.display === 'none' ? 'block' : 'none';
              hdr.classList.toggle('collapsed');
            });
          });

          // Drag-to-place handlers
          npcSidebarList.querySelectorAll('.npc-sidebar-item').forEach(function(el) {
            el.addEventListener('dragstart', function(e) {
              e.dataTransfer.setData('text/plain', JSON.stringify({
                npcId: parseInt(el.getAttribute('data-npc-id')),
                npcName: el.getAttribute('data-npc-name'),
                npcAvatar: el.getAttribute('data-npc-avatar'),
                npcMaxHp: parseInt(el.getAttribute('data-npc-max-hp')) || 0
              }));
              e.dataTransfer.effectAllowed = 'copy';
            });
            // Click also places at map center
            el.addEventListener('click', function() {
              var center = leafletMap.getCenter();
              var pct = latLngToPct(center);
              placeNpcOnMap(
                parseInt(el.getAttribute('data-npc-id')),
                el.getAttribute('data-npc-name'),
                el.getAttribute('data-npc-avatar'),
                parseInt(el.getAttribute('data-npc-max-hp')) || 0,
                pct.x, pct.y
              );
            });
          });
        }
        renderSidebar('');
        npcSidebarSearch.value = '';
        npcSidebarSearch.oninput = function() { renderSidebar(this.value); };
      });
    }

    // Drop handler on map container
    var mapContainer = document.getElementById('map-container');
    mapContainer.addEventListener('dragover', function(e) { e.preventDefault(); e.dataTransfer.dropEffect = 'copy'; });
    mapContainer.addEventListener('drop', function(e) {
      e.preventDefault();
      try {
        var data = JSON.parse(e.dataTransfer.getData('text/plain'));
        if (!data.npcId) return;
        var containerRect = mapContainer.getBoundingClientRect();
        var mx = e.clientX - containerRect.left;
        var my = e.clientY - containerRect.top;
        var latlng = leafletMap.containerPointToLatLng([mx, my]);
        var pct = latLngToPct(latlng);
        if (pct.x < 0 || pct.x > 100 || pct.y < 0 || pct.y > 100) return;
        placeNpcOnMap(data.npcId, data.npcName, data.npcAvatar, data.npcMaxHp, pct.x, pct.y);
      } catch(err) {}
    });

    npcPickerBtn.addEventListener('click', function() {
      var visible = npcSidebar.style.display !== 'none';
      npcSidebar.style.display = visible ? 'none' : 'block';
      if (!visible) loadNpcSidebar();
    });
    npcSidebarClose.addEventListener('click', function() {
      npcSidebar.style.display = 'none';
    });
    npcSidebarManage.addEventListener('click', function() {
      document.getElementById('npc-library-modal').style.display = 'flex';
      loadNpcLibrary();
    });

    // NPC Library Management
    var npcLibraryBtn = document.getElementById('npc-library-btn');
    var npcLibraryModal = document.getElementById('npc-library-modal');
    var npcLibraryList = document.getElementById('npc-library-list');

    function loadNpcLibrary() {
      npcLibraryList.innerHTML = '<p class="text-muted">Loading...</p>';
      fetch('/map/npcs').then(function(r) { return r.json(); }).then(function(data) {
        var npcs = data.npcs || [];
        var cats = data.categories || [];

        // Update category checkboxes in form
        var catCheckboxes = document.getElementById('npc-form-cats');
        if (cats.length === 0) {
          catCheckboxes.innerHTML = '<span class="text-muted" style="font-size:0.75rem;">No categories yet</span>';
        } else {
          var cbHtml = '';
          cats.forEach(function(c) {
            cbHtml += '<label style="display:flex;align-items:center;gap:0.2rem;font-size:0.8rem;cursor:pointer;">'
              + '<input type="checkbox" class="npc-cat-checkbox" value="' + c.id + '" style="margin:0;"> ' + escHtml(c.name) + '</label>';
          });
          catCheckboxes.innerHTML = cbHtml;
        }

        // Update cat management list
        var catList = document.getElementById('npc-cat-list');
        if (cats.length === 0) {
          catList.innerHTML = '<p class="text-muted" style="font-size:0.8rem;">No categories yet.</p>';
        } else {
          var catHtml = '';
          cats.forEach(function(c) {
            catHtml += '<div style="display:flex;justify-content:space-between;align-items:center;padding:0.2rem 0;"><span style="font-size:0.85rem;">' + escHtml(c.name) + '</span>'
              + '<button type="button" class="btn btn-small btn-danger" data-delete-cat="' + c.id + '" style="font-size:0.65rem;padding:0.1rem 0.3rem;">&times;</button></div>';
          });
          catList.innerHTML = catHtml;
          catList.querySelectorAll('[data-delete-cat]').forEach(function(btn) {
            btn.addEventListener('click', function() {
              if (!confirm('Delete this category?')) return;
              fetch('/map/npcs/categories/' + btn.getAttribute('data-delete-cat') + '/delete', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'X-CSRF-Token': csrfToken }
              }).then(function(r) { return r.json(); }).then(function(d) { if (d.success) { loadNpcLibrary(); loadNpcSidebar(); } });
            });
          });
        }

        // Render NPC list
        if (npcs.length === 0) {
          npcLibraryList.innerHTML = '<p class="text-muted">No NPCs created yet.</p>';
        } else {
          var catNames = {};
          cats.forEach(function(c) { catNames[c.id] = c.name; });
          var html = '';
          npcs.forEach(function(n) {
            var avatarHtml = n.avatar
              ? '<img src="' + escHtml(n.avatar) + '" style="width:28px;height:28px;border-radius:50%;object-fit:cover;border:2px solid #c0392b;">'
              : '<div style="width:28px;height:28px;border-radius:50%;background:var(--bg-darker);border:2px solid #c0392b;display:flex;align-items:center;justify-content:center;color:#e74c3c;font-size:0.75rem;font-weight:700;">' + escHtml(n.name.charAt(0).toUpperCase()) + '</div>';
            var catLabels = (n.category_ids || []).map(function(cid) { return catNames[cid] || ''; }).filter(Boolean);
            var catLabel = catLabels.join(', ');
            html += '<div style="display:flex;align-items:center;gap:0.5rem;padding:0.35rem 0;border-bottom:1px solid var(--border);">'
              + avatarHtml
              + '<div style="flex:1;min-width:0;"><div style="font-weight:600;font-size:0.85rem;">' + escHtml(n.name) + '</div>'
              + '<div class="text-muted" style="font-size:0.7rem;">' + (n.max_hp > 0 ? 'HP: ' + n.max_hp : 'No HP') + (catLabel ? ' ¬∑ ' + escHtml(catLabel) : '') + '</div></div>'
              + '<div style="display:flex;gap:0.25rem;">'
              + '<button type="button" class="btn btn-small btn-outline" data-edit-npc="' + n.id + '" style="font-size:0.65rem;padding:0.1rem 0.3rem;">Edit</button>'
              + '<button type="button" class="btn btn-small btn-danger" data-delete-npc="' + n.id + '" style="font-size:0.65rem;padding:0.1rem 0.3rem;">&times;</button>'
              + '</div></div>';
          });
          npcLibraryList.innerHTML = html;

          // Edit NPC buttons
          npcLibraryList.querySelectorAll('[data-edit-npc]').forEach(function(btn) {
            btn.addEventListener('click', function() {
              var npc = npcs.find(function(n) { return n.id === parseInt(btn.getAttribute('data-edit-npc')); });
              if (!npc) return;
              document.getElementById('npc-form-section').style.display = 'block';
              document.getElementById('npc-form-title').textContent = 'Edit NPC';
              document.getElementById('npc-form-id').value = npc.id;
              document.getElementById('npc-form-name').value = npc.name;
              document.getElementById('npc-form-hp').value = npc.max_hp || 0;
              // Set multi-category checkboxes
              var editCatIds = npc.category_ids || (npc.category_id ? [npc.category_id] : []);
              document.querySelectorAll('.npc-cat-checkbox').forEach(function(cb) {
                cb.checked = editCatIds.indexOf(parseInt(cb.value)) !== -1;
              });
              document.getElementById('npc-form-notes').value = npc.notes || '';
            });
          });

          // Delete NPC buttons
          npcLibraryList.querySelectorAll('[data-delete-npc]').forEach(function(btn) {
            btn.addEventListener('click', function() {
              if (!confirm('Delete this NPC from the library?')) return;
              fetch('/map/npcs/' + btn.getAttribute('data-delete-npc') + '/delete', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'X-CSRF-Token': csrfToken }
              }).then(function(r) { return r.json(); }).then(function(d) { if (d.success) { loadNpcLibrary(); loadNpcSidebar(); } });
            });
          });
        }
      });
    }

    npcLibraryBtn.addEventListener('click', function() {
      npcLibraryModal.style.display = 'flex';
      loadNpcLibrary();
    });

    // Category management toggle
    document.getElementById('npc-cat-manage-btn').addEventListener('click', function() {
      var sec = document.getElementById('npc-cat-section');
      sec.style.display = sec.style.display === 'none' ? 'block' : 'none';
    });

    // Add category
    document.getElementById('npc-add-cat-btn').addEventListener('click', function() {
      var input = document.getElementById('npc-new-cat-name');
      var name = input.value.trim();
      if (!name) return;
      fetch('/map/npcs/categories', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'X-CSRF-Token': csrfToken },
        body: JSON.stringify({ name: name })
      }).then(function(r) { return r.json(); }).then(function(d) {
        if (d.success) { input.value = ''; loadNpcLibrary(); loadNpcSidebar(); }
      });
    });

    // Create NPC button
    document.getElementById('npc-create-btn').addEventListener('click', function() {
      document.getElementById('npc-form-section').style.display = 'block';
      document.getElementById('npc-form-title').textContent = 'Create NPC';
      document.getElementById('npc-form-id').value = '';
      document.getElementById('npc-form-name').value = '';
      document.getElementById('npc-form-hp').value = '0';
      document.querySelectorAll('.npc-cat-checkbox').forEach(function(cb) { cb.checked = false; });
      document.getElementById('npc-form-notes').value = '';
      document.getElementById('npc-form-avatar').value = '';
      document.getElementById('npc-form-source-type').value = 'custom';
      document.getElementById('npc-form-source-key').value = '';
      document.getElementById('npc-form-avatar-preview').innerHTML = '';
      document.getElementById('npc-source-section').style.display = 'block';
      // Reset source buttons
      document.querySelectorAll('.npc-source-btn').forEach(function(b) {
        b.classList.remove('active', 'btn-primary');
        b.classList.add('btn-outline');
      });
      var customBtn = document.querySelector('.npc-source-btn[data-source="custom"]');
      customBtn.classList.add('active', 'btn-primary');
      customBtn.classList.remove('btn-outline');
      document.getElementById('npc-vault-search').style.display = 'none';
      document.getElementById('npc-avatar-auto-section').style.display = 'none';
      document.getElementById('npc-fetch-avatar-status').textContent = '';
    });

    // NPC Source selector ‚Äî uses local Vault API
    var npcCurrentSource = 'custom';
    var npcVaultApiMap = {
      bestiary: '/vault/monsters?search='
    };
    document.querySelectorAll('.npc-source-btn').forEach(function(btn) {
      btn.addEventListener('click', function() {
        document.querySelectorAll('.npc-source-btn').forEach(function(b) {
          b.classList.remove('active', 'btn-primary');
          b.classList.add('btn-outline');
        });
        btn.classList.add('active', 'btn-primary');
        btn.classList.remove('btn-outline');
        npcCurrentSource = btn.getAttribute('data-source');
        document.getElementById('npc-form-source-type').value = npcCurrentSource;
        document.getElementById('npc-form-source-key').value = '';
        document.getElementById('npc-avatar-auto-section').style.display = (npcCurrentSource === 'bestiary') ? 'block' : 'none';
        document.getElementById('npc-fetch-avatar-status').textContent = '';
        if (npcCurrentSource === 'custom') {
          document.getElementById('npc-vault-search').style.display = 'none';
        } else {
          document.getElementById('npc-vault-search').style.display = 'block';
          document.getElementById('npc-vault-query').value = '';
          document.getElementById('npc-vault-results').innerHTML = '<p class="text-muted" style="font-size:0.8rem;">Type a name and click Search</p>';
          document.getElementById('npc-vault-query').focus();
        }
      });
    });

    // Vault search
    function npcVaultSearch() {
      var q = document.getElementById('npc-vault-query').value.trim();
      if (!q) return;
      var apiUrl = npcVaultApiMap[npcCurrentSource];
      if (!apiUrl) return;
      var results = document.getElementById('npc-vault-results');
      results.innerHTML = '<p class="text-muted" style="font-size:0.8rem;">Searching...</p>';
      fetch(apiUrl + encodeURIComponent(q))
        .then(function(r) { return r.json(); })
        .then(function(data) {
          var items = data.results || [];
          if (!items.length) {
            results.innerHTML = '<p class="text-muted" style="font-size:0.8rem;">No results found</p>';
            return;
          }
          var html = '';
          items.slice(0, 25).forEach(function(item) {
            var name = item.name || 'Unknown';
            var key = item.key || item.slug || '';
            var hp = 0;
            var notes = '';
            if (npcCurrentSource === 'bestiary') {
              hp = item.hp || item.hit_points || 0;
              var cr = item.cr || item.challenge_rating || '';
              var type = item.type || '';
              var size = item.size || '';
              notes = (size ? size + ' ' : '') + (type ? type : '') + (cr ? ' (CR ' + cr + ')' : '');
            }
            html += '<div class="npc-vault-item" style="display:flex;align-items:center;gap:0.5rem;padding:0.35rem 0.4rem;border-bottom:1px solid var(--border);cursor:pointer;" data-name="' + name.replace(/"/g, '&quot;') + '" data-key="' + key + '" data-hp="' + hp + '" data-notes="' + notes.replace(/"/g, '&quot;') + '">';
            html += '<div style="flex:1;min-width:0;"><div style="font-size:0.85rem;font-weight:600;">' + name + '</div>';
            if (notes) html += '<div style="font-size:0.7rem;color:var(--text-secondary);overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">' + notes + '</div>';
            html += '</div>';
            if (hp) html += '<span style="font-size:0.75rem;color:var(--gold);">HP ' + hp + '</span>';
            html += '</div>';
          });
          results.innerHTML = html;
          // Click to fill form ‚Äî fetch detail for HP if bestiary
          results.querySelectorAll('.npc-vault-item').forEach(function(el) {
            el.addEventListener('click', function() {
              var itemName = el.getAttribute('data-name');
              var itemKey = el.getAttribute('data-key');
              var itemNotes = el.getAttribute('data-notes');
              document.getElementById('npc-form-name').value = itemName;
              document.getElementById('npc-form-source-key').value = itemKey;
              if (itemNotes) document.getElementById('npc-form-notes').value = itemNotes;
              document.getElementById('npc-form-avatar-preview').innerHTML = '';
              document.getElementById('npc-fetch-avatar-status').textContent = '';
              // Highlight selected item
              results.querySelectorAll('.npc-vault-item').forEach(function(r) { r.style.background = ''; });
              el.style.background = 'rgba(212,175,55,0.15)';
              // Fetch details for HP (bestiary has HP in detail only)
              if (npcCurrentSource === 'bestiary' && itemKey) {
                fetch('/vault/monsters/' + encodeURIComponent(itemKey))
                  .then(function(r) { return r.json(); })
                  .then(function(detail) {
                    if (detail.hp) {
                      var hpNum = parseInt(detail.hp);
                      if (hpNum > 0) document.getElementById('npc-form-hp').value = hpNum;
                    }
                    var detailNotes = [];
                    if (detail.type) detailNotes.push(detail.type);
                    if (detail.cr) detailNotes.push('CR ' + detail.cr);
                    if (detail.alignment) detailNotes.push(detail.alignment);
                    if (detailNotes.length) document.getElementById('npc-form-notes').value = detailNotes.join(' | ');
                  }).catch(function() {});
              }
            });
          });
        }).catch(function() {
          results.innerHTML = '<p class="text-muted" style="font-size:0.8rem;">Search failed</p>';
        });
    }
    document.getElementById('npc-vault-search-btn').addEventListener('click', npcVaultSearch);
    document.getElementById('npc-vault-query').addEventListener('keydown', function(e) {
      if (e.key === 'Enter') { e.preventDefault(); npcVaultSearch(); }
    });

    // Fetch avatar from D&D 5e API button
    document.getElementById('npc-fetch-avatar-btn').addEventListener('click', function() {
      var npcName = document.getElementById('npc-form-name').value.trim();
      if (!npcName) {
        document.getElementById('npc-fetch-avatar-status').textContent = 'Select a creature first';
        return;
      }
      var statusEl = document.getElementById('npc-fetch-avatar-status');
      statusEl.textContent = 'Searching for avatar...';
      statusEl.style.color = 'var(--text-secondary)';
      this.disabled = true;
      var btn = this;
      // Convert name to dnd5eapi key format: lowercase, spaces to hyphens, remove special chars
      var apiKey = npcName.toLowerCase().replace(/[^a-z0-9\s-]/g, '').replace(/\s+/g, '-');
      fetch('https://www.dnd5eapi.co/api/monsters/' + encodeURIComponent(apiKey))
        .then(function(r) { return r.json(); })
        .then(function(monster) {
          if (monster.image) {
            var imageUrl = 'https://www.dnd5eapi.co' + monster.image;
            document.getElementById('npc-form-avatar-preview').innerHTML = '<img src="' + imageUrl + '" style="max-width:60px;max-height:60px;border-radius:50%;border:2px solid var(--gold);margin-top:0.25rem;" title="D&amp;D 5e SRD image"><input type="hidden" name="avatar_url" value="' + imageUrl + '">';
            statusEl.textContent = 'Avatar found!';
            statusEl.style.color = 'var(--gold)';
          } else {
            statusEl.textContent = 'No image available for this creature';
            statusEl.style.color = 'var(--text-secondary)';
          }
          btn.disabled = false;
        }).catch(function() {
          statusEl.textContent = 'Creature not found in SRD';
          statusEl.style.color = 'var(--text-secondary)';
          btn.disabled = false;
        });
    });

    // NPC Form submit
    document.getElementById('npc-form').addEventListener('submit', function(e) {
      e.preventDefault();
      var formData = new FormData(this);
      formData.append('source_type', document.getElementById('npc-form-source-type').value);
      formData.append('source_key', document.getElementById('npc-form-source-key').value);
      // Collect checked category IDs
      document.querySelectorAll('.npc-cat-checkbox:checked').forEach(function(cb) {
        formData.append('category_ids', cb.value);
      });
      var npcId = document.getElementById('npc-form-id').value;
      var url = npcId ? '/map/npcs/' + npcId + '/edit' : '/map/npcs';
      fetch(url, {
        method: 'POST',
        headers: { 'X-CSRF-Token': csrfToken },
        body: formData
      }).then(function(r) { return r.json(); }).then(function(d) {
        if (d.success) {
          document.getElementById('npc-form-section').style.display = 'none';
          loadNpcLibrary();
          loadNpcSidebar();
        } else {
          alert(d.error || 'Failed');
        }
      });
    });
  }

  // ---- Table interactions ----
  document.addEventListener('click', function(e) {
    var btn = e.target.closest('[data-table-edit-loc]');
    if (btn) {
      var id = parseInt(btn.getAttribute('data-table-edit-loc'), 10);
      var l = locById[id];
      if (l) openEditLocation(l.id, l.name, l.description || '', l.icon);
    }

    var pinBtn = e.target.closest('[data-center-loc]');
    if (pinBtn) {
      var locId = parseInt(pinBtn.getAttribute('data-center-loc'), 10);
      var loc = locById[locId];
      if (loc) {
        var ll = pctToLatLng(loc.x, loc.y);
        leafletMap.setView(ll, 1, { animate: true });
        document.getElementById('map-wrapper').scrollIntoView({ behavior: 'smooth' });
      }
    }

    var childBtn = e.target.closest('[data-center-child]');
    if (childBtn) {
      var childId = parseInt(childBtn.getAttribute('data-center-child'), 10);
      var child = childMaps.find(function(c) { return c.id === childId; });
      if (child) {
        var ll = pctToLatLng(child.pin_x || 50, child.pin_y || 50);
        leafletMap.setView(ll, 1, { animate: true });
        document.getElementById('map-wrapper').scrollIntoView({ behavior: 'smooth' });
      }
    }

    var linkBtn = e.target.closest('[data-center-link]');
    if (linkBtn) {
      var lx = parseFloat(linkBtn.getAttribute('data-link-x')) || 50;
      var ly = parseFloat(linkBtn.getAttribute('data-link-y')) || 50;
      var ll = pctToLatLng(lx, ly);
      leafletMap.setView(ll, 1, { animate: true });
      document.getElementById('map-wrapper').scrollIntoView({ behavior: 'smooth' });
    }
  });

  // ---- Real-time map updates via SSE ----
  if (typeof EventSource !== 'undefined') {
    try {
      var mapSSE = new EventSource('/api/events');
      var mapUpdatePending = false;
      mapSSE.addEventListener('map-update', function(e) {
        try {
          var data = JSON.parse(e.data);
          if (data.mapId !== mapData.id) return;
          // Debounce rapid updates
          if (mapUpdatePending) return;
          mapUpdatePending = true;
          setTimeout(function() {
            mapUpdatePending = false;
            refreshMapTokens();
          }, 200);
        } catch(err) {}
      });
    } catch(e) {}
  }

  function refreshMapTokens() {
    fetch('/map/<%= map.id %>/token-state')
      .then(function(r) { return r.json(); })
      .then(function(state) {
        // --- Reconcile player tokens ---
        var newTokenIds = {};
        (state.tokens || []).forEach(function(t) {
          newTokenIds[t.id] = true;
          var existing = tokenMarkers[t.id];
          if (existing) {
            // Update position
            var ll = pctToLatLng(t.x, t.y);
            existing.setLatLng(ll);
            // Update existing tokensData entry
            for (var i = 0; i < tokensData.length; i++) {
              if (tokensData[i].id === t.id) {
                tokensData[i].x = t.x;
                tokensData[i].y = t.y;
                tokensData[i].scale = t.scale;
                tokensData[i].char_name = t.char_name;
                tokensData[i].char_avatar = t.char_avatar;
                tokensData[i].conditions = t.conditions || [];
                existing.setIcon(makeTokenIcon(tokensData[i]));
                break;
              }
            }
          } else {
            // New token ‚Äî add it
            var token = { id: t.id, character_id: t.character_id, x: t.x, y: t.y, scale: t.scale,
              char_name: t.char_name, char_avatar: t.char_avatar, char_user_id: t.char_user_id, conditions: t.conditions || [] };
            tokensData.push(token);
            var ll = pctToLatLng(t.x, t.y);
            var draggable = isDM || (t.char_user_id === currentUserId);
            var marker = L.marker(ll, { icon: makeTokenIcon(token), draggable: draggable }).addTo(leafletMap);
            tokenMarkers[t.id] = marker;
            bindTokenPopup(marker, token);
            if (draggable) {
              marker.on('dragend', function() {
                var pct = latLngToPct(marker.getLatLng());
                fetch('/map/<%= map.id %>/tokens/' + token.id + '/move', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json', 'X-CSRF-Token': csrfToken },
                  body: JSON.stringify({ x: pct.x, y: pct.y })
                });
              });
            }
          }
        });
        // Remove deleted tokens
        for (var tid in tokenMarkers) {
          if (!newTokenIds[tid]) {
            leafletMap.removeLayer(tokenMarkers[tid]);
            delete tokenMarkers[tid];
            tokensData = tokensData.filter(function(t) { return t.id !== parseInt(tid); });
          }
        }

        // --- Reconcile NPC tokens ---
        var newNpcIds = {};
        (state.npcTokens || []).forEach(function(nt) {
          newNpcIds[nt.id] = true;
          var existing = npcMarkers[nt.id];
          if (existing) {
            // Update position
            var ll = pctToLatLng(nt.x, nt.y);
            existing.setLatLng(ll);
            // Update data and icon
            var dataIdx = -1;
            for (var i = 0; i < npcTokensData.length; i++) {
              if (npcTokensData[i].id === nt.id) { dataIdx = i; break; }
            }
            if (dataIdx >= 0) {
              npcTokensData[dataIdx] = nt;
            }
            existing.setIcon(makeNpcTokenIcon(nt));
            // If popup is open, skip rebind to preserve user interaction
            if (!existing.getPopup() || !existing.getPopup().isOpen()) {
              bindNpcPopup(existing, nt);
            }
          } else {
            // New NPC token ‚Äî add it
            npcTokensData.push(nt);
            var ll = pctToLatLng(nt.x, nt.y);
            var npcOpts = { icon: makeNpcTokenIcon(nt), draggable: isDM };
            if (!isDM) npcOpts.pane = 'npcPane';
            var marker = L.marker(ll, npcOpts).addTo(leafletMap);
            npcMarkers[nt.id] = marker;
            bindNpcPopup(marker, nt);
            if (isDM) {
              (function(npcNt) {
                marker.on('dragend', function() {
                  var pct = latLngToPct(marker.getLatLng());
                  fetch('/map/<%= map.id %>/npc-tokens/' + npcNt.id + '/move', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'X-CSRF-Token': csrfToken },
                    body: JSON.stringify({ x: pct.x, y: pct.y })
                  });
                });
              })(nt);
            }
          }
        });
        // Remove deleted/hidden NPC tokens
        for (var nid in npcMarkers) {
          if (!newNpcIds[nid]) {
            leafletMap.removeLayer(npcMarkers[nid]);
            delete npcMarkers[nid];
            npcTokensData = npcTokensData.filter(function(nt) { return nt.id !== parseInt(nid); });
          }
        }
      }).catch(function() {});
  }

  // ---- Multi-Select Tokens (DM only, Feature 6) ----
  var selectedTokens = new Map(); // key: type+id, value: { type, id, marker, tokenData }

  function getSelectionKey(type, id) { return type + '-' + id; }

  function selectMarker(info) {
    var el = info.marker.getElement();
    if (el) el.classList.add('token-multi-selected');
  }

  function deselectMarker(info) {
    var el = info.marker.getElement();
    if (el) el.classList.remove('token-multi-selected');
  }

  if (isDM) {
    // Ctrl+Click on map = deselect all
    leafletMap.on('click', function(e) {
      if (!e.originalEvent.ctrlKey && !e.originalEvent.metaKey) {
        selectedTokens.forEach(function(info) { deselectMarker(info); });
        selectedTokens.clear();
      }
    });

    // Wrap token marker creation to add Ctrl+Click and group drag
    function addMultiSelectToMarker(marker, type, id, tokenData) {
      marker.on('click', function(e) {
        if (e.originalEvent.ctrlKey || e.originalEvent.metaKey) {
          L.DomEvent.stopPropagation(e);
          var key = getSelectionKey(type, id);
          if (selectedTokens.has(key)) {
            deselectMarker(selectedTokens.get(key));
            selectedTokens.delete(key);
          } else {
            var info = { type: type, id: id, marker: marker, tokenData: tokenData };
            selectedTokens.set(key, info);
            selectMarker(info);
          }
        }
      });

      marker.on('dragstart', function() {
        // Store initial positions of all selected tokens
        selectedTokens.forEach(function(info) {
          info._startLatLng = info.marker.getLatLng();
        });
      });

      marker.on('drag', function(e) {
        var key = getSelectionKey(type, id);
        if (!selectedTokens.has(key)) return;
        if (selectedTokens.size <= 1) return;
        var newLatLng = marker.getLatLng();
        var startInfo = selectedTokens.get(key);
        if (!startInfo._startLatLng) return;
        var deltaLat = newLatLng.lat - startInfo._startLatLng.lat;
        var deltaLng = newLatLng.lng - startInfo._startLatLng.lng;
        selectedTokens.forEach(function(info, infoKey) {
          if (infoKey === key) return;
          if (!info._startLatLng) return;
          var newLat = info._startLatLng.lat + deltaLat;
          var newLng = info._startLatLng.lng + deltaLng;
          info.marker.setLatLng([newLat, newLng]);
        });
      });

      marker.on('dragend', function() {
        var key = getSelectionKey(type, id);
        if (!selectedTokens.has(key) || selectedTokens.size <= 1) return;
        // Save positions for all selected tokens
        selectedTokens.forEach(function(info) {
          var pct = latLngToPct(info.marker.getLatLng());
          var url = info.type === 'npc'
            ? '/map/<%= map.id %>/npc-tokens/' + info.id + '/move'
            : '/map/<%= map.id %>/tokens/' + info.id + '/move';
          fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'X-CSRF-Token': csrfToken },
            body: JSON.stringify({ x: pct.x, y: pct.y })
          });
        });
      });
    }

    // Attach multi-select to existing player tokens
    tokensData.forEach(function(t) {
      if (tokenMarkers[t.id]) addMultiSelectToMarker(tokenMarkers[t.id], 'player', t.id, t);
    });
    // Attach multi-select to existing NPC tokens
    npcTokensData.forEach(function(nt) {
      if (npcMarkers[nt.id]) addMultiSelectToMarker(npcMarkers[nt.id], 'npc', nt.id, nt);
    });
  }

  } // end initMap

  // Load image to get natural dimensions, then initialize
  if (mapImagePath) {
    var img = new Image();
    img.onload = function() {
      initMap(img.naturalWidth || 1000, img.naturalHeight || 700);
    };
    img.onerror = function() {
      initMap(1000, 700);
    };
    img.src = mapImagePath;
  } else {
    initMap(1000, 700);
  }
})();

<% if (isDM) { %>
function openEditLocation(id, name, desc, icon) {
  document.getElementById('edit-loc-form').action = '/map/<%= map.id %>/locations/' + id + '/edit';
  document.getElementById('edit-loc-name').value = name;
  document.getElementById('edit-loc-desc').value = desc;
  document.getElementById('edit-loc-icon').value = icon;
  document.getElementById('map-edit-modal').style.display = 'block';
}
<% } %>
</script>

<%- include('partials/foot') %>
